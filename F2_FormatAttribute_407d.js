//F2_FormatAttribute_407d.js / CS4//© 20.03.09 / Hans Haesler, Châtelard 52, CH-1018 Lausanne//Dient zum Ausziehen der Attribute der Absatz- und Zeichenvorlagenif (app.documents.length == 0) {	alert ("Es ist kein Dokument offen.", "Achtung");	exit();}// prüfen, ob Absatzformat-Gruppen bestehenparaGroups = app.documents[0].paragraphStyleGroups;var nPSG = paraGroups.length;// prüfen, ob Zeichenformat-Gruppen bestehencharGroups = app.documents[0].characterStyleGroups;var nCSG = charGroups.length;//--- die Liste der Absatzformatnamen aufstellen ---//if (nPSG == 0) {	var dlogPStyles = app.documents[0].paragraphStyles.everyItem().name;	// das erste Element durch ein Sternchen ersetzen	dlogPStyles[0] = "*";	// zu Beginn ein leeres Element einfügen	dlogPStyles = [""].concat(dlogPStyles);	nDlogPStyles = dlogPStyles.length;}else {	pGroupNames = paraGroups.everyItem().name;	pGroupNames = ["[Root]"].concat(pGroupNames);	var curName;	var dlogPStyles = app.documents[0].paragraphStyles.everyItem().name;	// bei jedem Element drei Leerräume einfügen	for (var i=0; i<dlogPStyles.length; i++) {		curName = "   " + dlogPStyles[i];		dlogPStyles[i] = curName;	}	// das erste Element durch "[Root]" ersetzen	dlogPStyles[0] = "[Root]";	// zu Beginn ein Sternchen einfügen	dlogPStyles = ["*"].concat(dlogPStyles);	// zu Beginn ein leeres Element einfügen	dlogPStyles = [""].concat(dlogPStyles);	var curGroup;	var curParaStyles;	// eine Schleife durch die Gruppen	for (var i=0; i<nPSG; i++) {		curGroup = paraGroups[i];		curParaStyles = curGroup.paragraphStyles.everyItem().name;		// bei jedem Element drei Leerräume einfügen		for (var k=0; k<curParaStyles.length; k++) {			curName = "   " + curParaStyles[k];			curParaStyles[k] = curName;		}		// ein Element mit dem Namen der Gruppe voranstellen		curParaStyles = [curGroup.name].concat(curParaStyles);		dlogPStyles = dlogPStyles.concat(curParaStyles);	}	nDlogPStyles = dlogPStyles.length;	// die Positionen der Gruppennamen feststellen	var pGroupIDs = new Array ();	pGroupIDs.push(0);	for (var i=2; i<nDlogPStyles; i++) {		if (dlogPStyles[i][0] != " ") {			pGroupIDs.push(i);		}	}	// die Reihenfolge der Liste umkehren	pGroupIDs.reverse();}//--- die Liste der Zeichenformatnamen aufstellen ---//if (nCSG == 0) {	var dlogCStyles = app.documents[0].characterStyles.everyItem().name;	// das erste Element durch ein Sternchen ersetzen	dlogCStyles[0] = "*";	// zu Beginn ein leeres Element einfügen	dlogCStyles = [""].concat(dlogCStyles);	nDlogCStyles = dlogCStyles.length;}else {	cGroupNames = charGroups.everyItem().name;	cGroupNames = ["[Root]"].concat(cGroupNames);	var dlogCStyles = app.documents[0].characterStyles.everyItem().name;	// bei jedem Element drei Leerräume einfügen	for (var i=0; i<dlogCStyles.length; i++) {		curName = "   " + dlogCStyles[i];		dlogCStyles[i] = curName;	}	// das erste Element durch "[Root]" ersetzen	dlogCStyles[0] = "[Root]";	// zu Beginn ein Sternchen einfügen	dlogCStyles = ["*"].concat(dlogCStyles);	// zu Beginn ein leeres Element einfügen	dlogCStyles = [""].concat(dlogCStyles);	// eine Schleife durch die Gruppen	var curGroup;	var curCharStyles;	for (var i=0; i<nCSG; i++) {		curGroup = charGroups[i];		curCharStyles = curGroup.characterStyles.everyItem().name;		// bei jedem Element drei Leerräume einfügen		for (var k=0; k<curCharStyles.length; k++) {			curName = "   " + curCharStyles[k];			curCharStyles[k] = curName;		}		// ein Element mit dem Namen der Gruppe voranstellen		curCharStyles = [curGroup.name].concat(curCharStyles);		dlogCStyles = dlogCStyles.concat(curCharStyles);	}	nDlogCStyles = dlogCStyles.length;	// die Positionen der Gruppennamen feststellen	var cGroupIDs = new Array ();	cGroupIDs.push(0);	for (var i=2; i<nDlogCStyles; i++) {		if (dlogCStyles[i][0] != " ") {			cGroupIDs.push(i);		}	}	// die Reihenfolge der Liste umkehren	cGroupIDs.reverse();}// Dialoge, welche eventuell im Speicher geblieben sind, löschentry {	app.dialogs.everyItem().destroy();}catch (e) {}// vorbeugenderweise das Anzeigen von Dialogen aktivierenapp.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;// einen Dialog erzeugenvar aDialog = app.dialogs.add({name:"Das Format auswählen", canCancel:true});with (aDialog) {	with (dialogColumns.add()) {		with (dialogRows.add()) {			staticTexts.add({staticLabel:"Absatzformate:"});			staticTexts.add({staticLabel:" "});		}		with (borderPanels.add()) {			with (dialogColumns.add()) {				var paraName = dropdowns.add({stringList:dlogPStyles, selectedIndex:0, minWidth:180});			}		}		with (dialogRows.add()) {			staticTexts.add({staticLabel:"Zeichenformate:"});			staticTexts.add({staticLabel:" "});		}		with (borderPanels.add()) {			with (dialogColumns.add()) {				var charName = dropdowns.add({stringList:dlogCStyles, selectedIndex:0, minWidth:180});			}		}	}	with (dialogColumns.add()) {		staticTexts.add({staticLabel:"", minWidth:4});	}}// den Dialog zeigenif (aDialog.show() == true) {	// die Wahl des Anwenders übernehmen	var paraID = paraName.selectedIndex;	var charID = charName.selectedIndex;	// den Dialog aus dem Speicher entfernen	aDialog.destroy();}else {	aDialog.destroy();	exit();}// den Namen des Dokuments speichernvar docName = app.documents[0].name;// die Wahl des Anwenders prüfenif (paraID != 0) {	var curPara ;	var grpName;	var newDocP = makeDoc();	var newParaDoc = newDocP[0];	var nParaStyles;	var oldY1 = newDocP[1];	var oldX1 = newDocP[2];	var oldY2 = newDocP[3];	var oldX2 = newDocP[4];	var pCtr = 0;	if (paraID == 1) {		var paraString = "";		try {			// wenn das Sternchen gewählt worden ist, versuchen, 			// den Inhalt des Textrahmens "ParaStyles" zu speichern			paraString = app.documents.item(docName).textFrames.item("ParaStyles").parentStory.contents;		}		catch (e) {		}		if (paraString != "") {			paraStyles = paraString.split("\r");			nParaStyles = paraStyles.length;			// wenn keine Formatgruppen vorhanden sind			if (nPSG == 0) {				for (var s=0; s<nParaStyles; s++) {					curPara = paraStyles[s];					getParaDefs(pCtr, curPara, "", docName, newParaDoc, false);					pCtr++;				}			}			// die Behandlung der Gruppen ist etwas komplizierter			else {				for (var s=0; s<nParaStyles; s++) {					curPara = paraStyles[s];					if (curPara[0] != " ") {						grpName = curPara;					}					else {						curPara = curPara.slice(3);						getParaDefs(pCtr, curPara, grpName, docName, newParaDoc, false);						pCtr++;					}				}			}		}		// wenn der Textrahmen "ParaStyles" nicht vorhanden ist ...		else {		// ... falls keine Formatgruppen vorhanden sind ...			if (nPSG == 0) {				for (var s=2; s<nDlogPStyles; s++) {					curPara = dlogPStyles[s];					getParaDefs(pCtr, curPara, "", docName, newParaDoc, false);					pCtr++;				}			}			// ... sonst die komplizierte Behandlung der Gruppen durchführen ...			else {				for (var s=2; s<nDlogPStyles; s++) {					curPara = dlogPStyles[s];					if (curPara[0] != " ") {						grpName = curPara;						if (grpName != "[Root]") {							curGroup = app.documents.item(docName).paragraphStyleGroups.item(grpName);							paraStyles = curGroup.allParagraphStyles;							nParaStyles = paraStyles.length;							for (var j=0; j<nParaStyles; j++) {								curPara = paraStyles[j].name;								getParaDefs(pCtr, curPara, grpName, docName, newParaDoc, false);								pCtr++;							}						}						else {							paraStyles = app.documents.item(docName).paragraphStyles;							var nParaStyles = paraStyles.length;							for (var j=1; j<nParaStyles; j++) {								curPara = paraStyles[j].name;								getParaDefs(pCtr, curPara, grpName, docName, newParaDoc, false);								pCtr++;							}						}					}				}			}		}	}	// bei der Wahl eines anderen Artikels wird nur das betreffende Format behandelt ...	else {		curPara = dlogPStyles[paraID];		// wenn keine Gruppen vorhanden sind, ist es einfacher ...		if (nPSG == 0) {			getParaDefs(pCtr, curPara, "", docName, newParaDoc, true);			pCtr++;		}		// ... sonst müssen die Gruppen berücksichtigt werden		else {			// wenn ein Gruppenname ausgewählt ist, dann wird die ganze Gruppe ausgegeben			if (curPara[0] != " ") {				grpName = curPara;				if (grpName != "[Root]") {					curGroup = app.documents.item(docName).paragraphStyleGroups.item(grpName);					paraStyles = curGroup.allParagraphStyles;					nParaStyles = paraStyles.length;					for (var s=0; s<nParaStyles; s++) {						curPara = paraStyles[s].name;						getParaDefs(pCtr, curPara, grpName, docName, newParaDoc, false);						pCtr++;					}				}				else {					paraStyles = app.documents.item(docName).paragraphStyles;					nParaStyles = paraStyles.length;					for (var s=1; s<nParaStyles; s++) {						curPara = paraStyles[s].name;						getParaDefs(pCtr, curPara, grpName, docName, newParaDoc, false);						pCtr++;					}				}			}			// wenn ein Formatname ausgewählt ist, muss der Gruppenname festgestellt werden			else {				grpName = undefined;				// die drei Leerräume entfernen				curPara = curPara.slice(3);				// die Liste der Gruppennamen umkehren				pGroupNames.reverse();				// eine Schleife durch die Liste				for (var s=0; s<pGroupIDs.length; s++) {					// wenn die Position der Gruppe kleiner ist als jene des Formates					// den zugehörigen Namen übernehmen					if (pGroupIDs[s]<paraID) {						grpName = pGroupNames[s];						break;					}				}				if (grpName != undefined) {					getParaDefs(pCtr, curPara, grpName, docName, newParaDoc, true);					pCtr++;				}			}		}	}	// die Funktion aufrufen, welche die geänderten Vorgaben zurücksetzt	restoreApp(oldY1, oldX1, oldY2, oldX2);	// die erste Seite anzeigen	app.activeWindow.activeSpread = app.documents[0].spreads[0];}// dasselbe mit einem gewählten Zeichenformatif (charID != 0) {	var charStyles;	var curChar;	var curGroup;	var grpName;	var nCharStyles;	var newDocC = makeDoc();	var newCharDoc = newDocC[0];	var oldY1 = newDocC[1];	var oldX1 = newDocC[2];	var oldY2 = newDocC[3];	var oldX2 = newDocC[4];	var pCtr = 0;	if (charID == 1) {		var charString = "";		try {			// wenn das Sternchen gewählt worden ist, versuchen, 			// den Inhalt des Textrahmens "CharStyles" zu speichern			charString = app.documents.item(docName).textFrames.item("CharStyles").parentStory.contents;		}		catch (e) {		}		if (charString != "") {			charStyles = charString.split("\r");			nCharStyles = charStyles.length;			// wenn keine Formatgruppen vorhanden sind			if (nCSG == 0) {				for (var s=0; s<nCharStyles; s++) {					curChar = charStyles[s];					getCharDefs(pCtr, curChar, "", docName, newCharDoc, false);					pCtr++;				}			}			// die Behandlung der Gruppen ist etwas komplizierter			else {				for (var s=0; s<nCharStyles; s++) {					curChar = charStyles[s];					if (curChar[0] != " ") {						grpName = curChar;					}					else {						curChar = curChar.slice(3);						getCharDefs(pCtr, curChar, grpName, docName, newCharDoc, false);						pCtr++;					}				}			}		}		// wenn der Textrahmen "CharStyles" nicht vorhanden ist und ...		else {			// ... falls keine Formatgruppen vorhanden sind ...			if (nCSG == 0) {				for (var s=2; s<nDlogCStyles; s++) {					curChar = dlogCStyles[s];					getCharDefs(pCtr, curChar, "", docName, newCharDoc, false);					pCtr++;				}			}			// ... sonst die komplizierte Behandlung der Gruppen durchführen			else {				for (var s=2; s<nDlogCStyles; s++) {					curChar = dlogCStyles[s];					if (curChar[0] != " ") {						grpName = curChar;						if (grpName != "[Root]") {							curGroup = app.documents.item(docName).characterStyleGroups.item(grpName);							charStyles = curGroup.allCharacterStyles;							nCharStyles = charStyles.length;							for (var j=0; j<nCharStyles; j++) {								curChar = charStyles[j].name;								getCharDefs(pCtr, curChar, grpName, docName, newCharDoc, false);								pCtr++;							}						}						else {							charStyles = app.documents.item(docName).characterStyles;							nCharStyles = charStyles.length;							for (var j=1; j<nCharStyles; j++) {								curChar = charStyles[j].name;								getCharDefs(pCtr, curChar, grpName, docName, newCharDoc, false);								pCtr++;							}						}					}				}			}		}	}	// bei der Wahl eines anderen Artikels wird nur das betreffende Format behandelt ...	else {		curChar = dlogCStyles[charID];		// wenn keine Gruppen vorhanden sind, ist es einfacher ...		if (nCSG == 0) {			getCharDefs(pCtr, curChar, "", docName, newCharDoc, true);			pCtr++;		}		// ... sonst müssen die Gruppen berücksichtigt werden		else {			// wenn ein Gruppenname ausgewählt ist, dann wird die ganze Gruppe ausgegeben			if (curChar[0] != " ") {				grpName = curChar;				if (grpName != "[Root]") {					curGroup = app.documents.item(docName).characterStyleGroups.item(grpName);					charStyles = curGroup.allCharacterStyles;					nCharStyles = charStyles.length;					for (var s=0; s<nCharStyles; s++) {						curChar = charStyles[s].name;						getCharDefs(pCtr, curChar, grpName, docName, newCharDoc, false);						pCtr++;					}				}				else {					charStyles = app.documents.item(docName).characterStyles;					nCharStyles = charStyles.length;					for (var s=1; s<nCharStyles; s++) {						curChar = charStyles[s].name;						getCharDefs(pCtr, curChar, grpName, docName, newCharDoc, false);						pCtr++;					}				}			}			// wenn ein Formatname ausgewählt ist, muss der Gruppenname festgestellt werden			else {				grpName = undefined;				// die drei Leerräume entfernen				curChar = curChar.slice(3);				// die Liste der Gruppennamen umkehren				cGroupNames.reverse();				// eine Schleife durch die Liste				for (var s=0; s<cGroupIDs.length; s++) {					// wenn die Position der Gruppe kleiner ist als jene des Formates					// den zugehörigen Namen übernehmen					if (cGroupIDs[s]<charID) {						grpName = cGroupNames[s];						break;					}				}				if (grpName != undefined) {					getCharDefs(pCtr, curChar, grpName, docName, newCharDoc, true);					pCtr++;				}			}		}	}	// die Funktion aufrufen, welche die geänderten Vorgaben zurücksetzt	restoreApp(oldY1, oldX1, oldY2, oldX2);	// die erste Seite anzeigen	app.activeWindow.activeSpread = app.documents[0].spreads[0];}// ***************************************************//                    die Attribute                   //       des gewählten Absatzformates auflisten       // ***************************************************function getParaDefs(pCtr, curPara, grpName, docName, newParaDoc, oneStyle) {	var snm = curPara;	try {		if (nPSG == 0) {			curProps = app.documents.item(docName).paragraphStyles.item(curPara).properties;			if (pCtr>0 && !oneStyle) {				newParaDoc.pages.add();			}		}		else {			if (grpName != "[Root]") {				var curGroup = app.documents.item(docName).paragraphStyleGroups.item(grpName);				var curStyle = curGroup.paragraphStyles.item(curPara);				curProps = curStyle.properties;				if (pCtr>0 && !oneStyle) {					newParaDoc.pages.add();				}			}			else {				curProps = app.documents.item(docName).paragraphStyles.item(curPara).properties;				if (pCtr>0 && !oneStyle) {					newParaDoc.pages.add();				}			}		}	}	catch (e) {		return;	}		// **********************************************	// das Panel "Allgemein"	// **********************************************	var bas;	var gen = new Array ();	var grp = 0;	var nsp = "";	if (nPSG != 0) {		grp = 1;		gen.push("\tPosition\t" + grpName);	}	var bon = curProps.basedOn.name;	if (bon == undefined) {		bas = "[Kein Absatzformat]";	}	else {		if (grp != 0) {			var bap = curProps.basedOn.parent.name;			if (bap == docName) {				bas = bon;			}			else {				bas = bon + " (" + bap + ")";			}		}		else {			bas = bon;		}	}	gen.push("\tBasiert auf\t" + bas);	var nxt = curProps.nextStyle.name;	if (nxt == undefined) {		nxt = "[Kein Absatzformat]";	}	if (grp != 0) {		try {			var nsp = curProps.nextStyle.parent.name;		}		catch (e) {		}		if (nsp != docName && nsp != "") {			nxt = nxt + " (" + nsp + ")";		}	}	gen.push("\tNächstes Format\t" + nxt);	genString = gen.join("\r");		// **********************************************	// das Panel "Grundlegende Zeichenformate"	// **********************************************	var scf = new Array ();	var aft = curProps.appliedFont.name;	var afn = aft.split("\t")[0];	var afs = aft.split("\t")[1];	scf.push("\tSchriftfamilie\t" + afn);	scf.push("\tSchriftschnitt\t" + afs);	var siz = curProps.pointSize;	scf.push("\tSchriftgrad\t" + siz + " Pt");	var led = curProps.leading;	if (led == 1635019116) {		var ald = curProps.autoLeading;		led = "(" + ((siz * ald) / 100) + " Pt)";	}	else {		led = led + " Pt";	}	scf.push("\tZeilenabstand\t" + led);	var kmd = curProps.kerningMethod;	if (kmd == "Metrics") {		kmd = "Metrisch";	}	else if (kmd == "Optical") {		kmd = "Optisch";	}	else if (kmd == "None") {		kmd = "Ohne";	}	scf.push("\tKerning\t" + kmd);	var trk = curProps.tracking;	scf.push("\tLaufweite\t" + trk);	var cap = curProps.capitalization;	if (cap == 1852797549) {		cap = "Normal";	}	else if (cap == 1936548720) {		cap = "Kapitälchen";	}	else if (cap == 1634493296) {		cap = "Großbuchstaben";	}	else if (cap == 1664250723) {		cap = "OpenType-Kapitälchen";	}	scf.push("\tBuchstabenart\t" + cap);	var pos = curProps.position;	if (pos == 1852797549) {		pos = "Normal";	}	else if (pos == 1936749411) {		pos = "Hochgestellt";	}	else if (pos == 1935831907) {		pos = "Tiefgestellt";	}	else if (pos == 1884247155) {		pos = "OpenType-Hochstellung";	}	else if (pos == 1884247138) {		pos = "OpenType-Tiefstellung";	}	else if (pos == 1884247150) {		pos = "OpenType-Zähler";	}	else if (pos == 1884247140) {		pos = "OpenType-Nenner";	}	scf.push("\tPosition\t" + pos);	var und = curProps.underline;	if (und == false) {		und = "nicht aktiviert";	}	else {		und = "aktiviert";	}	scf.push("\tUnterstrichen\t" + und);	var stk = curProps.strikeThru;	if (stk == false) {		stk = "nicht aktiviert";	}	else {		stk = "aktiviert";	}	scf.push("\tDurchgestrichen\t" + stk);	var lig = curProps.ligatures;	if (lig == false) {		lig = "nicht aktiviert";	}	else {		lig = "aktiviert";	}	scf.push("\tLigaturen\t" + lig);	var nbr = curProps.noBreak;	if (nbr == false) {nbr = "nicht aktiviert"; }	else if (nbr == true) {nbr = "aktiviert"; }	scf.push("\tKein Umbruch\t" + nbr);	stdString = scf.join("\r");		// **********************************************	// das Panel "Erweiterte Zeichenformate"	// **********************************************	var sca = new Array ();	var hsc = curProps.horizontalScale;	sca.push("\tHorizontal skalieren\t" + hsc + "%");	var vsc = curProps.verticalScale;	sca.push("\tVertikal skalieren\t" + vsc + "%");	var bls = curProps.baselineShift;	sca.push("\tGrundlinienversatz\t" + bls + " Pt");	var skw = curProps.skew;	sca.push("\tVerzerren\t" + skw + "°");	var lga = curProps.appliedLanguage.name;	sca.push("\tSprache\t" + lga);	advString = sca.join("\r");		// **********************************************	// das Panel "Einzüge und Abstände"	// **********************************************	var ind = new Array ();	var jst = curProps.justification;	if (jst == 1818584692) {		jst = "Links";	}	else if (jst == 1667591796) {		jst = "Mitte";	}	else if (jst == 1919379572) {		jst = "Rechts";	}	else if (jst == 1818915700) {		jst = "Blocksatz, letzte linksbündig";	}	else if (jst == 1919578996) {		jst = "Blocksatz, letzte zentriert";	}	else if (jst == 1667920756) {		jst = "Blocksatz, letzte zentriert";	}	else if (jst == 1718971500) {		jst = "Blocksatz";	}	else if (jst == 1630691955) {		jst = "Am Rücken";	}	else if (jst == 1633772147) {		jst = "Nicht am Rücken";	}	ind.push("\tAusrichtung\t" + jst);	var brl = curProps.balanceRaggedLines;	if (brl == 1114394470) {		brl = "nicht aktiviert";	}	else if (brl == 1114396261) {		brl = "aktiviert (V-förmig)";	}	else if (brl == 1114391921) {		brl = "aktiviert (Ausgleich)";	}	else if (brl == 1114394745) {		brl = "aktiviert (Pyramidenform)";	}	ind.push("\tFlattersatzausgleich\t" + brl);	var iea = curProps.ignoreEdgeAlignment;	if (iea == false) { iea = "nicht aktiviert"; }	else if (iea == true) { iea = "aktiviert"; }	ind.push("\tOpt. Rand ignorieren\t" + iea);	var lin = curProps.leftIndent;	ind.push("\tEinzug links\t" + lin + " mm");	var fln = curProps.firstLineIndent;	ind.push("\tEinzug erste Zeile\t" + fln + " mm");	var rin = curProps.rightIndent;	ind.push("\tEinzug rechts\t" + rin + " mm");	var lln = curProps.lastLineIndent;	ind.push("\tEinzug letzte Zeile\t" + lln + " mm");	var spb = curProps.spaceBefore;	ind.push("\tAbstand vor\t" + spb + " mm");	var spa = curProps.spaceAfter;	ind.push("\tAbstand nach\t" + spa + " mm");	var atb = curProps.alignToBaseline;	if (atb == true) {		if (curProps.gridAlignFirstLineOnly == false) {			atb = "Alle Zeilen";		}		else {			atb = "Nur erste Zeile";		}	}	else {		atb = "Ohne";	}	ind.push("\tAn Raster ausrichten\t" + atb);	var insString = ind.join("\r");		// **********************************************	// das Panel "Tabulatoren"	// **********************************************	var tbl = curProps.tabList;	var nTabs = tbl.length;	var tabString;	if (nTabs == 0) {		tabString = "\tnicht definiert";	}	else {		var aChar;		var allTabs = new Array ();		var curAlg;		var curPos;		var curLead;		allTabs.push("\taliniert\tPosition\tFüllzeichen\tAusr.");		for (var i=0; i<nTabs; i++) {			aChar = "";			curAlg = tbl[i].alignment;			if (curAlg == 1818584692) {				curAlg = "links";			}			else if (curAlg == 1667591796) {				curAlg = "zentriert";			}			else if (curAlg == 1919379572) {				curAlg = "rechts";			}			else if (curAlg == 1952604515) {				curAlg = "ausricht.";				aChar = tbl[i].alignmentCharacter;			}			curPos = tbl[i].position;			curLead = tbl[i].leader;			allTabs.push("\t" + curAlg + "\t" + curPos + "\t" + curLead + "\t" + aChar);		}		tabString = allTabs.join("\r");	}		// **********************************************	// das Panel "Absatzlinien"	// **********************************************	var rab = curProps.ruleAbove;	if (rab == false) {		rabString = "\tLinie darüber\tnicht aktiviert";	}	else {		rap = new Array ();		rap.push("\tLinie darüber\taktiviert");		var raw = curProps.ruleAboveLineWeight;		rap.push("\tStärke\t" + raw + " Pt");		var rat = curProps.ruleAboveType.name;		rap.push("\tArt\t" + rat);		var rac = curProps.ruleAboveColor;		if (rac == "Text Color") {			rac = "(Textfarbe)";		}		else {			rac = rac.name;			if (rac == "None") { rac = "[Ohne]"; }			else if (rac == "Black") { rac = "[Schwarz]"; }			else if (rac == "Paper") { rac = "[Papier]"; }			else if (rac == "Registration") { rac = "[Passermarken]"; }		}		rap.push("\tFarbe\t" + rac);		var rai = curProps.ruleAboveTint;		if (rai == -1) { rai = 100; }		rap.push("\tFarbton\t" + rai + "%");		var raop = curProps.ruleAboveOverPrint;		if (raop == false) { raop = "nein"; }		else if (raop == true) { raop = "ja"; }		else if (raop == undefined) { raop = "nicht definiert"; }		rap.push("\tKontur überdrucken\t" + raop);		var ragc = curProps.ruleAboveGapColor;		if (ragc == "Text Color") {			ragc = "(Textfarbe)";		}		else {			ragc = ragc.name;			if (ragc == "None") { ragc = "[Ohne]"; }			else if (ragc == "Black") { ragc = "[Schwarz]"; }			else if (ragc == "Paper") { ragc = "[Papier]"; }			else if (ragc == "Registration") { ragc = "[Passermarken]"; }		}		if (ragc != "[Ohne]") {			rap.push("\tFarbe für Lücke\t" + ragc);			var ragi = curProps.ruleAboveGapTint;			if (ragi == -1) { ragi = 100; }			rap.push("\tFarbton für Lücke\t" + ragi + "%");			var rago = curProps.ruleAboveGapOverprint;			if (rago == false) { rago = "nein"; }			else if (rago == true) { rago = "ja"; }			else if (rago == undefined) { rago = "nicht definiert"; }			rap.push("\tLücke überdrucken\t" + rago);		}		var rawi = curProps.ruleAboveWidth;		if (rawi == 1265399652) { rawi = "Spalte"; }		else if (rawi == 1886681207) { rawi = "Text"; }		rap.push("\tBreite\t" + rawi);		var rao = curProps.ruleAboveOffset;		rap.push("\tOffset\t" + rao + " mm");		var rali = curProps.ruleAboveLeftIndent;		rap.push("\tEinzug links\t" + rali + " mm");		var rari = curProps.ruleAboveRightIndent;		rap.push("\tEinzug rechts\t" + rari + " mm");		var kraf = curProps.keepRuleAboveInFrame;		if (kraf == true) {			kraf = "aktiviert";		}		else {			kraf = "nicht aktiviert";		}		rap.push("\tIm Rahmen belassen\t" + kraf);		rabString = rap.join("\r");	}	var rbe = curProps.ruleBelow;	if (rbe == false) {		rbeString = "\tLinie darunter\tnicht aktiviert";	}	else {		rbp = new Array ();		rbp.push("\tLinie darunter\taktiviert");		var rbw = curProps.ruleBelowLineWeight;		rbp.push("\tStärke\t" + rbw + " Pt");		var rbt = curProps.ruleBelowType.name;		rbp.push("\tArt\t" + rbt);		var rbc = curProps.ruleBelowColor;		if (rbc == "Text Color") {			rbc = "(Textfarbe)";		}		else {			rbc = rbc.name;			if (rbc == "None") { rbc = "[Ohne]"; }			else if (rbc == "Black") { rbc = "[Schwarz]"; }			else if (rbc == "Paper") { rbc = "[Papier]"; }			else if (rbc == "Registration") { rbc = "[Passermarken]"; }		}		rbp.push("\tFarbe\t" + rbc);		var rbi = curProps.ruleBelowTint;		if (rbi == -1) { rbi = 100; }		rbp.push("\tFarbton\t" + rbi + "%");		var rbop = curProps.ruleBelowOverPrint;		if (rbop == false) { rbop = "nein"; }		else if (rbop == true) { rbop = "ja"; }		else if (rbop == undefined) { rbop = "nicht definiert"; }		rbp.push("\tKontur überdrucken\t" + rbop);		var rbgc = curProps.ruleBelowGapColor;		if (rbgc == "Text Color") {			rbgc = "(Textfarbe)";		}		else {			rbgc = rbgc.name;			if (rbgc == "None") { rbgc = "[Ohne]"; }			else if (rbgc == "Black") { rbgc = "[Schwarz]"; }			else if (rbgc == "Paper") { rbgc = "[Papier]"; }			else if (rbgc == "Registration") { rbgc = "[Passermarken]"; }		}		if (rbgc != "[Ohne]") {			rbp.push("\tFarbe für Lücke\t" + rbgc);			var rbgi = curProps.ruleBelowGapTint;			if (rbgi == -1) { rbgi = 100; }			rbp.push("\tFarbton für Lücke\t" + rbgi + "%");			var rbgo = curProps.ruleBelowGapOverPrint;			if (rbgo == false) { rbgo = "nein"; }			else if (rbgo == true) { rbgo = "ja"; }			else if (rbgo == undefined) { rbgo = "nicht definiert"; }			rbp.push("\tLücke überdrucken\t" + rbgo);		}		var rbwi = curProps.ruleBelowWidth;		if (rbwi == 1265399652) { rbwi = "Spalte"; }		else if (rbwi == 1886681207) { rbwi = "Text"; }		rbp.push("\tBreite\t" + rbwi);		var rbo = curProps.ruleBelowOffset;		rbp.push("\tOffset\t" + rbo + " mm");		var rbli = curProps.ruleBelowLeftIndent;		rbp.push("\tEinzug links\t" + rbli + " mm");		var rbri = curProps.ruleBelowRightIndent;		rbp.push("\tEinzug rechts\t" + rbri + " mm");		rbeString = rbp.join("\r");	}		// **********************************************	// das Panel "Umbruchoptionen"	// **********************************************	var kee = new Array ();	var kwn = curProps.keepWithNext;	kee.push("\tNicht trenn. nächste\t" + kwn + " Zeilen");	var kat = curProps.keepAllLinesTogether;	if (kat == false) {		var fir = curProps.keepFirstLines;		var las = curProps.keepLastLines;		kee.push("\tNicht trennen\tAnfang: " + fir + " Z. / Ende: " + las + " Z.");	}	else {		kee.push("\tZeilen nicht trennen\tAlle Zeilen im Absatz");	}	var stp = curProps.startParagraph;	if (stp == 1851945579) {		kee.push("\tAbsatzbeginn\tBeliebige Position");	}	else if (stp == 1667396203) {		kee.push("\tAbsatzbeginn\tIn nächster Spalte");	}	else if (stp == 1313235563) {		kee.push("\tAbsatzbeginn\tIn nächstem Rahmen");	}	else if (stp == 1885500011) {		kee.push("\tAbsatzbeginn\tAuf nächster Seite");	}	else if (stp == 1332765291) {		kee.push("\tAbsatzbeginn\tAuf nächster ungerader Seite");	}	else if (stp == 1164993131) {		kee.push("\tAbsatzbeginn\tAuf nächster gerader Seite");	}	var kesString = kee.join("\r");		// **********************************************	// das Panel "Silbentrennung"	// **********************************************	var hyp = new Array ();	var hpn = curProps.hyphenation;	if (hpn == false) {		hyp.push("\tnicht aktiviert");	}	else {		var hwl = curProps.hyphenateWordsLongerThan;		hyp.push("\tWörter mit mindest.\t" + hwl + " Buchstaben");		var haf = curProps.hyphenateAfterFirst;		hyp.push("\tKürzeste Vorsilbe\t" + haf + " Buchstaben");		var hbl = curProps.hyphenateBeforeLast;		hyp.push("\tKürzeste Nachsilbe\t" + hbl + " Buchstaben");		var hll = curProps.hyphenateLadderLimit;		hyp.push("\tMax. Trennstriche\t" + hll + " Trennstriche");		var hzn = curProps.hyphenationZone;		hyp.push("\tTrennbereich\t" + hzn + " mm");		var hwt = curProps.hyphenWeight;		hyp.push("\tWert\t" + hwt);		var hcw = curProps.hyphenateCapitalizedWords;		if (hcw == true) {			hcw = "Trennung aktiviert";		}		else {			hcw = "Trennung nicht aktiviert";		}		hyp.push("\tGroßgeschriebenes\t" + hcw);		var hlw = curProps.hyphenateLastWord;		if (hlw == true) {			hlw = "aktiviert";		}		else {			hlw = "nicht aktiviert";		}		hyp.push("\tLetztes Wort trennen\t" + hlw);		var hac = curProps.hyphenateAcrossColumns;		if (hac == true) {			hac = "Trennung aktiviert";		}		else {			hac = "Trennung nicht aktiviert";		}		hyp.push("\tSilben Spalte hinweg\t" + hac);	}	var hysString = hyp.join("\r");		// **********************************************	// das Panel "Abstände"	// **********************************************	var jst = new Array ();	var mws = curProps.minimumWordSpacing;	var dws = curProps.desiredWordSpacing;	var xws = curProps.maximumWordSpacing;	jst.push("\tWortabstand\t" + mws + "%\t" + dws + "%\t" + xws + "%");	var mls = curProps.minimumLetterSpacing;	var dls = curProps.desiredLetterSpacing;	var xls = curProps.maximumLetterSpacing;	jst.push("\tZeichenabstand\t" + mls + "%\t" + dls + "%\t" + xls + "%");	var mgs = curProps.minimumGlyphScaling;	var dgs = curProps.desiredGlyphScaling;	var xgs = curProps.maximumGlyphScaling;	jst.push("\tGlyphenabstand\t" + mgs + "%\t" + dgs + "%\t" + xgs + "%");	var ald = curProps.autoLeading;	jst.push("\tAuto. Zeilenabstand\t" + ald + "%");	var swj = curProps.singleWordJustification;	if (swj == 1818584692) {		swj = "Linksbündig ausrichten";	}	else if (swj == 1667591796) {		swj = "Zentrieren";	}	else if (swj == 1919379572) {		swj = "Rechtsbündig ausrichten";	}	else if (swj == 1718971500) {		swj = "Blocksatz";	}	jst.push("\tEinzelnes Wort\t" + swj);	var com = curProps.composer;	jst.push("\tSetzer\t" + com);	var jusString = jst.join("\r");		// ************************************************	// das Panel "Initialen und verschachtelte Formate"	// ************************************************	var noStyle = app.documents.item(docName).characterStyles[0].name;	var dcp = new Array ();	var dcl = curProps.dropCapLines;	dcp.push("Initialen\tZeilen\t" + dcl);	var csn;	var dcc = curProps.dropCapCharacters;	var dst = curProps.dropCapStyle.name;	if (dcc > 0) {		dcp.push("\tZeichen\t" + dcc);		if (nCSG == 0 || dst == noStyle) {			csn = dst;		}		else {			if (dst != noStyle) {				nsp = curProps.dropCapStyle.parent.name;				if (nsp == docName) {					csn = dst;				}				else {					csn = dst + " (" + nsp + ")";				}			}			else {				csn = noStyle;			}		}		dcp.push("\tZeichenformat\t" + csn);		var dcd = curProps.dropcapDetail;		if (dcd == 0) {			dcp.push("\tLinke Kante ausr.\tnicht aktiviert");			dcp.push("\tSkalierung Unterl.\tnicht aktiviert");		}		else if (dcd == 1) {			dcp.push("\tLinke Kante ausr.\taktiviert");			dcp.push("\tSkalierung Unterl.\tnicht aktiviert");		}		else if (dcd == 2) {			dcp.push("\tLinke Kante ausr.\tnicht aktiviert");			dcp.push("\tSkalierung Unterl.\taktiviert");		}		else if (dcd == 3) {			dcp.push("\tLinke Kante ausr.\taktiviert");			dcp.push("\tSkalierung Unterl.\taktiviert");		}		var dcsString = dcp.join("\r");	}	else {		var dcsString = "\tInitialen\tkeine Definition";	}		var nst = new Array ();	if (nPSG == 0 || grpName == "[Root]") {		var nes = app.documents.item(docName).paragraphStyles.item(snm).nestedStyles;	}	else {		var nes = curStyle.nestedStyles;	}	var nStyles = nes.length;	if (dst != noStyle) {		nDef = nStyles-1;		startVal = 1;	}	else {		nDef = nStyles;		startVal = 0;	}	if (nDef == 0) {		nst.push("\tVerschachtelte Form.\tkeine Definition");	}	else {		if (nDef == 1) {			nst.push("\tVerschachtelte Form.\t1 Definition");		}		else {			nst.push("\tVerschachtelte Form.\t" + nDef + " Definitionen");		}		var cst;		var inc;		var rep;		var dlm;		for (var x=startVal; x<nStyles; x++) {			csn = nes[x].appliedCharacterStyle.name;			if (nCSG != 0) {				if (csn != noStyle) {					nsp = nes[x].appliedCharacterStyle.parent.name;					if (nsp != docName) {						csn = csn + " (" + nsp + ")";					}				}			}			inc = nes[x].inclusive;			if (inc == true) { inc = "über"; }			else { inc = "bis"; }			rep = nes[x].repetition;			dlm = nes[x].delimiter;			if (dlm == 1380545132) {				nst.push("\tWiederholen: letzten\t" + rep + "  Formate");			}			else {				if (dlm == 1380541555) { dlm = "Sätze"; }				else if (dlm == 1380541559) { dlm = "Wörter"; }				else if (dlm == 1380541539) { dlm = "Zeichen"; }				else if (dlm == 1380541548) { dlm = "Buchstaben"; }				else if (dlm == 1380541507) { dlm = "Initiale"; }				else if (dlm == 1380541540) { dlm = "Ziffern"; }				else if (dlm == 1396855379) { dlm = "Endzeichen versch. Format"; }				else if (dlm == 1380541556) { dlm = "Tabulatorzeichen"; }				else if (dlm == 1397124194) { dlm = "Harter Zeilenumbruch"; }				else if (dlm == 1397319796) { dlm = "\"Einzug bis hierhin\"-Zeichen"; }				else if (dlm == 1397645907) { dlm = "Geschützte Leerzeichen"; }				else if (dlm == 1397058899) { dlm = "Geviert-Leerzeichen"; }				else if (dlm == 1397059155) { dlm = "Halbgeviert-Leerzeichen"; }				else if (dlm == 1380541545) { dlm = "Marke für verankert. Objekt"; }				else if (dlm == 1396797550) { dlm = "Autom. Seitenzahl"; }				else if (dlm == 1400073805) { dlm = "Abschnittsmarke"; }				nst.push("\tZeichenformat\t" + csn);				nst.push("\t" + inc + "   " + rep + "\t" + dlm);			}		}	}	var nssString = nst.join("\r");		var lst = new Array ();	if (nPSG == 0 || grpName == "[Root]") {		var nls = app.documents.item(docName).paragraphStyles.item(snm).nestedLineStyles;	}	else {		var nls = curStyle.nestedLineStyles;	}	var lDef = nls.length;	if (lDef == 0) {		lst.push("\tVersch. Zeilenform.\tkeine Definition");	}	else {		var lct;		var rlt;		if (lDef == 1) {			lst.push("\tVersch. Zeilenform.\t1 Definition");			csn = nls[0].appliedCharacterStyle.name;			if (nCSG != 0) {				if (csn != noStyle) {					nsp = nls[0].appliedCharacterStyle.parent.name;					if (nsp != docName) {						csn = csn + " (" + nsp + ")";					}				}			}			lct = nls[0].lineCount;			rlt = nls[0].repeatLast;			if (rlt == -1) {				if (lct == 1) {					lst.push("\tZF: " + csn + "\tfür 1 Zeile");				}				else {					lst.push("\tZF: " + csn + "\t" + lct + " Zeilen");				}			}			else {				if (rlt == 1) {					lst.push("\tWiederholen\tfür 1 Zeile");				}				else {					lst.push("\tWiederholen\tfür " + rlt + " Zeilen");				}			}		}		else {			lst.push("\tVersch. Zeilenform.\t" + lDef + " Definitionen");			for (var x=0; x<lDef; x++) {				csn = nls[x].appliedCharacterStyle.name;				if (nCSG != 0) {					if (csn != noStyle) {						nsp = nls[x].appliedCharacterStyle.parent.name;						if (nsp != docName) {							csn = csn + " (" + nsp + ")";						}					}				}				lct = nls[x].lineCount;				rlt = nls[x].repeatLast;				if (rlt == -1) {					if (lct == 1) {						lst.push("\t" + csn + "\tfür 1 Zeile");				}					else {						lst.push("\t" + csn + "\t" + lct + " Zeilen");					}				}				else {					if (rlt == 1) {						lst.push("\tWiederholen\tfür 1 Zeile");					}					else {						lst.push("\tWiederholen\tfür " + rlt + " Zeilen");					}				}			}		}	}	var nlsString = lst.join("\r");		// ***********************************************	// das Panel "GREP-Stil"	// ***********************************************	var gst = new Array ();	if (nPSG == 0 || grpName == "[Root]") {		var ngs = app.documents.item(docName).paragraphStyles.item(snm).nestedGrepStyles;	}	else {		var ngs = curStyle.nestedGrepStyles;	}	var gDef = ngs.length;	if (gDef == 0) {		gst.push("\tGREP-Stil\tkeine Definition");	}	else {		var gxp;		if (gDef == 1) {			gst.push("\tGREP-Stil\t1 Definition");			csn = ngs[0].appliedCharacterStyle.name;			if (nCSG != 0) {				if (csn != noStyle) {					nsp = ngs[0].appliedCharacterStyle.parent.name;					if (nsp != docName) {						csn = csn + " (" + nsp + ")";					}				}			}			gxp = ngs[0].grepExpression;			gst.push("\tStil anwenden\t" + csn);			gst.push("\tAuf Text\t" + gxp);		}		else {			gst.push("\tGREP-Stil\t" + gDef + " Definitionen");			for (var x=0; x<gDef; x++) {				csn = ngs[x].appliedCharacterStyle.name;				if (nCSG != 0) {					if (csn != noStyle) {						nsp = ngs[x].appliedCharacterStyle.parent.name;						if (nsp != docName) {							csn = csn + " (" + nsp + ")";						}					}				}				gxp = ngs[x].grepExpression;				gst.push("\tStil anwenden\t" + csn);				gst.push("\tAuf Text\t" + gxp);			}		}	}	var gstString = gst.join("\r");		// ***********************************************	// das Panel "Aufzählungszeichen und Nummerierung"	// ***********************************************	var ban = new Array ();	var bnt = curProps.bulletsAndNumberingListType;	if (bnt == 1280601711) {		ban.push("\tListentyp\tOhne");	}	else if (bnt == 1280598644) {		ban.push("\tListentyp\tAufzählungszeichen");		var bch = curProps.bulletChar.characterValue;		ban.push("\tAufzählungszeichen\t" + bch);		var nbt = curProps.bulletsTextAfter;		ban.push("\tText nach\t" + nbt);		csn = curProps.bulletsCharacterStyle.name;		if (nCSG != 0) {			if (csn != noStyle) {				nsp = curProps.bulletsCharacterStyle.parent.name;				if (nsp != docName) {					csn = csn + " (" + nsp + ")";				}			}		}		ban.push("\tZeichenformat\t" + csn);		ban.push("Position des Aufzählungszeichens");		var nba = curProps.bulletsAlignment;		if (nba == 1818584692) { nba = "Links"; }		else if (nba == 1667591796) { nba = "Mitte"; }		else if (nba == 1919379572) { nba = "Rechts"; }		ban.push("\tAusrichtung\t" + nba);		var bli = curProps.leftIndent;		ban.push("\tEinzug links\t" + bli + " mm");		var bfi = curProps.firstLineIndent;		ban.push("\tEinzug erste Zeile\t" + bfi + " mm");		try {			var tbl = curProps.tabList;			var btp = tbl[0].position;		}		catch (e) {			var btp = 12.7;		}		ban.push("\tTabulatorposition\t" + btp + " mm");	}	else if (bnt == 1280601709) {		ban.push("\tListentyp\tZahlen");		var nln = curProps.appliedNumberingList.name;		if (nln == "[Default]") {			nln = "[Standard]";		}		ban.push("\tListe\t" + nln);		var nle = curProps.numberingLevel;		ban.push("\tEbene\t" + nle);		var nst = curProps.numberingFormat;		ban.push("\tFormat\t" + nst);		var nex = curProps.numberingExpression;		ban.push("\tAnzahl\t" + nex);		csn = curProps.numberingCharacterStyle.name;		if (nCSG != 0) {			if (csn != noStyle) {				nsp = curProps.numberingCharacterStyle.parent.name;				if (nsp != docName) {					csn = csn + " (" + nsp + ")";				}			}		}		ban.push("\tZeichenformat\t" + csn);		var nct = curProps.numberingContinue;		if (nct) {			var nar = false;			if (nle > 1) {				var nar = curProps.numberingApplyRestartPolicy;			}			if (nar) {				ban.push("\tModus\tNummerierung fortführen");				ban.push("\tNeubeginn Numm.\tBeliebige vorherige Ebene");			}			else {				ban.push("\tModus\tNummerierung fortführen");			}		}		else {			var nsa = curProps.numberingStartAt;			ban.push("\tModus\tBeginnen mit: " + nsa);		}		var nna = curProps.numberingAlignment;		if (nna == 1818584692) { nna = "Links"; }		else if (nna == 1667591796) { nna = "Mitte"; }		else if (nna == 1919379572) { nna = "Rechts"; }		ban.push("\tAusrichtung\t" + nna);		var bli = curProps.leftIndent;		ban.push("\tEinzug links\t" + bli + " mm");		var bfi = curProps.firstLineIndent;		ban.push("\tEinzug erste Zeile\t" + bfi + " mm");		try {			var tbl = curProps.tabList;			var btp = tbl[0].position;		}		catch (e) {			var btp = 12.7;		}		ban.push("\tTabulatorposition\t" + btp + " mm");	}	var bnsString = ban.join("\r");		// **********************************************	// das Panel "Zeichenfarbe"	// **********************************************	var col = new Array ();	var fco = curProps.fillColor.name;	if (fco == "None") { fco = "[Ohne]"; }	else if (fco == "Black") { fco = "[Schwarz]"; }	else if (fco == "Paper") { fco = "[Papier]"; }	else if (fco == "Registration") { fco = "[Passermarken]"; }	col.push("\tZeichenfarbe\t" + fco);	var fti = curProps.fillTint;	if (fti == -1) {		fti = 100;	}	col.push("\tFarbton\t" + fti + "%");	var opf = curProps.overprintFill;	if (opf == true) {		opf = "ja";	}	else {		opf = "nein";	}	col.push("\tFläche überdrucken\t" + opf);	var sco = curProps.strokeColor.name;	if (sco == "None") { sco = "[Ohne]"; }	else if (sco == "Black") { sco = "[Schwarz]"; }	else if (sco == "Paper") { sco = "[Papier]"; }	else if (sco == "Registration") { sco = "[Passermarken]"; }	col.push("\tKontur: Farbe\t" + sco);	if (sco != "[Ohne]") {		var sti = curProps.strokeTint;		if (sti == -1) {			sti = 100;		}		col.push("\tKontur: Farbton\t" + sti + "%");		var swt = curProps.strokeWeight;		col.push("\tKontur: Stärke\t" + swt + " Pt");		var ops = curProps.overprintFill;		if (ops == true) {			ops = "ja";		}		else {			ops = "nein";		}		col.push("\tKontur überdrucken\t" + ops);		var mil = curProps.miterLimit;		col.push("\tKontur\tGehrungsgrenze: " + mil + " x");		var sta = curProps.strokeAlignment;		if (sta = 1936998735) {			col.push("\tKonturausrichtung\taußen ausrichten");		}		else if (sta = 1936998723) {			col.push("\tKonturausrichtung\tmittig ausrichten");		}		var ejo = curProps.endJoin;		if (ejo = 1835691886) {			col.push("\tKonturecken\tGehrungsecken");		}		else if (ejo = 1919577966) {			col.push("\tKonturecken\tAbgerundete Ecken");		}		else if (ejo = 1651142510) {			col.push("\tKonturecken\tAbgeflachte Ecken");		}	}	var colString = col.join("\r");		// **********************************************	// das Panel "OpenType-Funktionen"	// **********************************************	var otf = new Array ();	var vCtr = 0;	var oti = curProps.otfTitling;	if (oti == true) {		otf.push("\tGroßbuchstabenvar.\taktiviert");		vCtr++;	}	var ofs = curProps.otfSwash;	if (ofs == true) {		otf.push("\tVerschnörkelte Var.\taktiviert");		vCtr++;	}	var oca = curProps.otfContextualAlternate;	if (oca == true) {		otf.push("\tKontextbedingte Var.\taktiviert");		vCtr++;	}	var ord = curProps.otfOrdinal;	if (ord == true) {		otf.push("\tOrdinalzeichen\taktiviert");		vCtr++;	}	var fra = curProps.otfFraction;	if (fra == true) {		otf.push("\tBrüche\taktiviert");		vCtr++;	}	var lig = curProps.otfDiscretionaryLigature;	if (lig == true) {		otf.push("\tBedingte Ligaturen\taktiviert");		vCtr++;	}	var zer = curProps.otfSlashedZero;	if (zer == true) {		otf.push("\tNull mit Schrägstrich\taktiviert");		vCtr++;	}	if (vCtr == 0) {		otf.push("\tCheckboxen\tkeine ist aktiviert");	}	var ofs = curProps.otfFigureStyle;	if (ofs == 1147563124) {		otf.push("\tZahlenformat\tStandardzahlenformat");	}	else if (ofs == 1330932848) {		otf.push("\tZahlenformat\tVersalziffern für Tabellen");	}	else if (ofs == 1330933619) {		otf.push("\tZahlenformat\tProportionale Mediävalziffern");	}	else if (ofs == 1330931316) {		otf.push("\tZahlenformat\tProportionale Versalziffern");	}	else if (ofs == 1330933620) {		otf.push("\tZahlenformat\tMediävalziffern für Tabellen");	}	var pof = curProps.positionalForm;	if (pof == 1852796517) {		otf.push("\tPositionalform\tAllgemeine Form");	}	else if (pof == 1634756205) {		otf.push("\tPositionalform\tAutomatische Form");	}	else if (pof == 1768843636) {		otf.push("\tPositionalform\tInitialform");	}	else if (pof == 1835361385) {		otf.push("\tPositionalform\tMedialform");	}	else if (pof == 1718185569) {		otf.push("\tPositionalform\tFinalform");	}	else if (pof == 1769172844) {		otf.push("\tPositionalform\tIsolierte Form");	}	var oss = curProps.otfStylisticSets;	var moreThanOne = false;	if (oss == 0) {		otf.push("\tFormatsätze\tOhne");	}	else {		if (oss == 2) { oss = "1"; }		else if (oss == 4) { oss = "2"; }		else if (oss == 8) { oss = "3"; }		else if (oss == 16) { oss = "4"; }		else if (oss == 32) { oss = "5"; }		else if (oss == 64) { oss = "6"; }		else if (oss == 128) { oss = "7"; }		else if (oss == 256) { oss = "8"; }		else if (oss == 512) { oss = "9"; }		else if (oss == 1024) { oss = "10"; }		else if (oss == 2048) { oss = "11"; }		else if (oss == 4096) { oss = "12"; }		else if (oss == 8192) { oss = "13"; }		else if (oss == 16384) { oss = "14"; }		else if (oss == 32768) { oss = "15"; }		else if (oss == 65536) { oss = "16"; }		else if (oss == 131072) { oss = "17"; }		else if (oss == 262144) { oss = "18"; }		else if (oss == 524288) { oss = "19"; }		else if (oss == 1048576) { oss = "20"; }		else {			moreThanOne = true;			if (oss == 2097150) {				otf.push("\tFormatsätze\tSätze 1 bis 20");			}			else {				var valList = new Array (1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2);				var indList = new Array (20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);				var setList = new Array ();				for (var i=0; i<20; i++) {					curVal = oss - valList[i];					if (curVal > 0) {						oss = curVal;						setList.push(indList[i]);					}					else if (oss == valList[i]) {						setList.push(indList[i]);						break;					}				}				setList.reverse();				setString = setList.join(", ");				otf.push("\tFormatsätze\tSätze " + setString);			}		}		if (!moreThanOne) {			otf.push("\tFormatsätze\tSatz " + oss);		}	}	var otfString = otf.join("\r");		// **********************************************	// das Panel "Unterstreichungsoptionen"	// **********************************************	var uac = curProps.underline;	if (uac == false) {		undString = "\tUnterstreichung\tnicht aktiviert";	}	else {		var und = new Array ();		var unw = curProps.underlineWeight;		if (unw == -9999) {			und.push("\tStärke\tAutom.");		}		else {			und.push("\tStärke\t" + unw + " Pt");		}		var uno = curProps.underlineOffset;		if (uno == -9999) {			und.push("\tOffset\tAutom.");		}		else {			und.push("\tOffset\t" + uno + " Pt");		}		var unt = curProps.underlineType.name;		und.push("\tArt\t" + unt);		var unc = curProps.underlineColor;		if (unc == "Text Color") {			unc = "(Textfarbe)";		}		else {			unc = unc.name;			if (unc == "None") { unc = "[Ohne]"; }			else if (unc == "Black") { unc = "[Schwarz]"; }			else if (unc == "Paper") { unc = "[Papier]"; }			else if (unc == "Registration") { unc = "[Passermarken]"; }		}		und.push("\tFarbe\t" + unc);		var uni = curProps.underlineTint;		if (uni == -1) { uni = 100; }		und.push("\tFarbton\t" + uni + "%");		var unop = curProps.underlineOverprint;		if (unop == false) { unop = "nein"; }		else if (unop == true) { unop = "ja"; }		und.push("\tKontur überdrucken\t" + unop);		if (unt != "Durchgezogen") {			var ungc = curProps.underlineGapColor;			if (ungc == "Text Color") {				ungc = "(Textfarbe)";			}			else {				ungc = ungc.name;				if (ungc == "None") { ungc = "[Ohne]"; }				else if (ungc == "Black") { ungc = "[Schwarz]"; }				else if (ungc == "Paper") { ungc = "[Papier]"; }				else if (ungc == "Registration") { ungc = "[Passermarken]"; }			}			und.push("\tFarbe für Lücke\t" + ungc);			var ungi = curProps.underlineGapTint;			if (ungi == -1) { ungi = 100; }			und.push("\tFarbton für Lücke\t" + ungi + "%");			var ungo = curProps.underlineGapOverprint;			if (ungo == false) { ungo = "nein"; }			else if (ungo == true) { ungo = "ja"; }			else if (ungo == undefined) { ungo = "nicht definiert"; }			und.push("\tLücke überdrucken\t" + ungo);		}		undString = und.join("\r");	}		// **********************************************	// das Panel "Durchstreichungsoptionen"	// **********************************************	var sac = curProps.strikeThru;	if (sac == false) {		var strString = "\tDurchstreichung\tnicht aktiviert";	}	else {		var str = new Array ();		var stw = curProps.strikeThroughWeight;		if (stw == -9999) {			str.push("\tStärke\tAutom.");		}		else {			str.push("\tStärke\t" + stw + " Pt");		}		var sto = curProps.strikeThroughOffset;		if (sto == -9999) {			str.push("\tOffset\tAutom.");		}		else {			str.push("\tOffset\t" + sto + " Pt");		}		var stt = curProps.strikeThroughType.name;		str.push("\tArt\t" + stt);		var stc = curProps.strikeThroughColor;		if (stc == "Text Color") {			stc = "(Textfarbe)";		}		else {			stc = stc.name;			if (stc == "None") { stc = "[Ohne]"; }			else if (stc == "Black") { stc = "[Schwarz]"; }			else if (stc == "Paper") { stc = "[Papier]"; }			else if (stc == "Registration") { stc = "[Passermarken]"; }		}		str.push("\tFarbe\t" + stc);		var sti = curProps.strikeThroughTint;		if (sti == -1) { sti = 100; }		str.push("\tFarbton\t" + sti + "%");		var skop = curProps.strikeThroughOverprint;		if (skop == false) { skop = "nein"; }		else if (skop == true) { skop = "ja"; }		str.push("\tKontur überdrucken\t" + skop);		if (stt != "Durchgezogen") {			var stgc = curProps.strikeThroughGapColor;			if (stgc == "Text Color") {				stgc = "(Textfarbe)";			}			else {				stgc = stgc.name;				if (stgc == "None") { stgc = "[Ohne]"; }				else if (stgc == "Black") { stgc = "[Schwarz]"; }				else if (stgc == "Paper") { stgc = "[Papier]"; }				else if (stgc == "Registration") { stgc = "[Passermarken]"; }			}			str.push("\tFarbe für Lücke\t" + stgc);			var stgi = curProps.strikeThroughGapTint;			if (stgi == -1) { stgi = 100; }			str.push("\tFarbton für Lücke\t" + stgi + "%");			var stgo = curProps.strikeThroughGapOverprint;			if (stgo == false) { stgo = "nein"; }			else if (stgo == true) { stgo = "ja"; }			else if (stgo == undefined) { stgo = "nicht definiert"; }			str.push("\tLücke überdrucken\t" + stgo);		}		strString = str.join("\r");	}		// **********************************************	// einen Textrahmen erzeugen	var newFrame = newParaDoc.pages.item(-1).textFrames.add();	newFrame.properties = {geometricBounds:[12, 15, 285, 200]};	// zwei Spalten 	newFrame.textFramePreferences.textColumnCount = 2;		// eine neue Liste vorbereiten	var propsList = new Array (36);		// die Elemente zuweisen	propsList[0] = "Dokument  " + docName;	propsList[1] = "\r\tFormatname\t" + snm;	propsList[2] = genString; // Zeile 511	propsList[3] = "\rGrundlegende Zeichenformate"; // Zeile 558	propsList[4] = stdString;	propsList[5] = "\rErweiterte Zeichenformate"; // Zeile 658	propsList[6] = advString;	propsList[7] = "\rEinzüge und Abstände"; // Zeile 674	propsList[8] = insString;	propsList[9] = "\rTabulatoren"; // Zeile 752	propsList[10] = tabString;	propsList[11] = "\rAbsatzlinien"; // Zeile 791	propsList[12] = rabString;	propsList[13] = rbeString;	propsList[14] = "\rUmbruchoptionen"; // Zeile 933	propsList[15] = kesString;	propsList[16] = "\rSilbentrennung"; // Zeile 969	propsList[17] = hysString;	propsList[18] = "\rAbstände"; // Zeile 1017	propsList[19] = jusString;	propsList[20] = "\rInitialen und verschachtelte Formate"; // Zeile 1053	propsList[21] = dcsString;	propsList[22] = nssString;	propsList[23] = nlsString;	propsList[24] = "\rGREP-Stil"; // Zeile 1257	propsList[25] = gstString;	propsList[26] = "\rAufzählungszeichen und Nummerierung"; // Zeile 1308	propsList[27] = bnsString;	propsList[28] = "\rZeichenfarbe"; // Zeile 1412	propsList[29] = colString;	propsList[30] = "\rOpenType-Funktionen"; // Zeile 1479	propsList[31] = otfString;	propsList[32] = "\rUnterstreichungsoptionen"; // Zeile 1614	propsList[33] = undString;	propsList[34] = "\rDurchstreichungsoptionen"; // Zeile 1683	propsList[35] = strString;		// die Liste in eine Textkette verwandeln ...	var propsString = propsList.join("\r");	// ... in den Rahmen einsetzen ...	var curStory = newFrame.parentStory;	curStory.contents = propsString;	// ... und formatieren	try {		curStory.appliedParagraphStyle = newParaDoc.paragraphStyles.item("02_Definitionen");	}	catch (e) {	}	// die Tab-Stops für die Tabulatoren-Definitionen definieren und anwenden	if (!tabString.match("definiert")) {		var specTabs = new Array (4);		specTabs[0] = {alignment:TabStopAlignment.rightAlign, position:16};		specTabs[1] = {alignment:TabStopAlignment.leftAlign, position:20};		specTabs[2] = {alignment:TabStopAlignment.leftAlign, position:56};		specTabs[3] = {alignment:TabStopAlignment.leftAlign, position:80};		try {			curStory.paragraphs.itemByRange(39+grp, 40+grp+nTabs).tabList = specTabs;		}		catch (e) {		}	}	// die Untertitel formatieren	try {		curStory.paragraphs.item(0).appliedParagraphStyle = newParaDoc.paragraphStyles.item("01_Untertitel");	}	catch (e) {	}	var nParas = curStory.paragraphs.length;	for (var i=0; i<nParas; i++) {		if (curStory.paragraphs[i].characters.length == 1) {			try {				curStory.paragraphs.item(i+1).appliedParagraphStyle = newParaDoc.paragraphStyles.item("01_Untertitel");			}			catch (e) {			}		}	}	// einigen Zeichen wieder den Stil "Regular" zuweisen	try {		curStory.paragraphs.item(0).characters.itemByRange(0, 9).fontStyle = "Regular";	}	catch (e) {	}	try {		curStory.paragraphs.item(2).characters.itemByRange(0,11).fontStyle = "Regular";	}	catch (e) {	}		// die Anzahl Zeilen dreier Absätze prüfen und, falls notwendig, einen Shift-Return einfügen	var testPara1 = curStory.paragraphs.item(2); // Formatname	if (testPara1.lines.length == 2) {		try {			testPara1.characters.item(11).contents = 1397124194;			testPara1.insertionPoints.item(12).contents = 1397909876;		}		catch (e) {		}	}	var testPara2 = curStory.paragraphs.item(3+grp); // Basiert auf	if (testPara2.lines.length == 2) {		try {			testPara2.characters.item(12).contents = 1397124194;			testPara2.insertionPoints.item(13).contents = 1397909876;		}		catch (e) {		}	}	var testPara3 = curStory.paragraphs.item(4+grp); // Nächstes Format	if (testPara3.lines.length == 2) {		try {			testPara3.characters.item(16).contents = 1397124194;			testPara3.insertionPoints.item(17).contents = 1397909876;		}		catch (e) {		}	}	var testPara4 = curStory.paragraphs.item(25+grp); // Sprache	if (testPara4.lines.length == 2) {		try {			testPara4.characters.item(8).contents = 1397124194;			testPara4.insertionPoints.item(9).contents = 1397909876;		}		catch (e) {		}	}	// eine spezielle Tabstop-Definition für den Abschnitte "Abstände"	var startPara = 0;	for (var i = 50; i<curStory.paragraphs.length; i++) {		curPara = curStory.paragraphs[i];		if (curPara.fontStyle == "Bold") {			if (curPara.contents.match("Abstände")) {				startPara = i;				break;			}		}	}	if (startPara != 0) {		var justTabs = new Array (4);		justTabs[0] = {alignment:TabStopAlignment.rightAlign, position:36};		justTabs[1] = {alignment:TabStopAlignment.rightAlign, position:50};		justTabs[2] = {alignment:TabStopAlignment.rightAlign, position:65};		justTabs[3] = {alignment:TabStopAlignment.rightAlign, position:80};		try {			curStory.paragraphs.itemByRange(startPara+1, startPara+3).tabList = justTabs;		}		catch (e) {		}	}	// die Leerzeilen entfernen	app.findTextPreferences = app.changeTextPreferences = null;	app.findTextPreferences.findWhat = "\r\r";	app.changeTextPreferences.changeTo = "\r";	curStory.changeText();	app.findTextPreferences = app.changeTextPreferences = null;}// ***************************************************//                    die Attribute                   //      des gewählten Zeichenformates auflisten       // ***************************************************function getCharDefs(pCtr, curChar, grpName, docName, newCharDoc, oneStyle) {	var snm = curChar;	try {		if (nCSG == 0) {			curProps = app.documents.item(docName).characterStyles.item(curChar).properties;			if (pCtr>1 && pCtr%2==0) {				newCharDoc.pages.add();			}		}		else {			if (grpName != "[Root]") {				var curGroup = app.documents.item(docName).characterStyleGroups.item(grpName);				var curStyle = curGroup.characterStyles.item(curChar);				curProps = curStyle.properties;				if (pCtr>1 && pCtr%2==0) {					newCharDoc.pages.add();				}			}			else {				curProps = app.documents.item(docName).characterStyles.item(curChar).properties;				if (pCtr>1 && pCtr%2==0) {					newCharDoc.pages.add();				}			}		}	}	catch (e) {		return;	}		// **********************************************	// das Panel "Allgemein"	// **********************************************	var bas;	var gen = new Array ();	var grp = 0;	if (nCSG != 0) {		grp = 1;		gen.push("\tPosition\t" + grpName);	}	var bon = curProps.basedOn.name;	if (bon == undefined) {		bas = "[Ohne]";	}	else {		if (grp != 0) {			var bap = curProps.basedOn.parent.name;			if (bap == docName) {				bap = bon;			}			bas = bon + " (" + bap + ")";		}		else {			bas = bon;		}	}	gen.push("\tBasiert auf\t" + bas);	genString = gen.join("\r");		// **********************************************	// das Panel "Grundlegende Zeichenformate"	// **********************************************	var scf = new Array ();	var aft = curProps.appliedFont;	if (aft == "" || aft == 1851876449) {		aft = "nicht definiert";	}	scf.push("\tSchriftfamilie\t" + aft);	var afs = curProps.fontStyle;	if (afs == 1851876449) {		afs = "nicht definiert";	}	scf.push("\tSchriftschnitt\t" + afs);	var siz = curProps.pointSize;	if (siz != 1851876449) {		scf.push("\tSchriftgrad\t" + siz + " Pt");	}	else {		scf.push("\tSchriftgrad\tnicht definiert");	}	var led = curProps.leading;	if (led == 1635019116) {		var ald = curProps.autoLeading;		led = "(" + ((siz * ald) / 100) + " Pt)";	}	else if (led == 1851876449) {		led = "nicht definiert";	}	else {		led = led + " Pt";	}	scf.push("\tZeilenabstand\t" + led);	var kmd = curProps.kerningMethod;	if (kmd == "Metrics") {		kmd = "Metrisch";	}	else if (kmd == "Optical") {		kmd = "Optisch";	}	else if (kmd == "None") {		kmd = "Ohne";	}	else if (kmd == 1851876449) {		kmd = "nicht definiert";	}	scf.push("\tKerning\t" + kmd);	var trk = curProps.tracking;	if (trk == 1851876449) {		trk = "nicht definiert";	}	scf.push("\tLaufweite\t" + trk);	var cap = curProps.capitalization;	if (cap == 1852797549) {		cap = "Normal";	}	else if (cap == 1936548720) {		cap = "Kapitälchen";	}	else if (cap == 1634493296) {		cap = "Großbuchstaben";	}	else if (cap == 1664250723) {		cap = "OpenType-Kapitälchen";	}	else if (cap == 1851876449) {		cap = "nicht definiert";	}	scf.push("\tBuchstabenart\t" + cap);	var pos = curProps.position;	if (pos == 1852797549) {		pos = "Normal";	}	else if (pos == 1936749411) {		pos = "Hochgestellt";	}	else if (pos == 1935831907) {		pos = "Tiefgestellt";	}	else if (pos == 1884247155) {		pos = "OpenType-Hochstellung";	}	else if (pos == 1884247138) {		pos = "OpenType-Tiefstellung";	}	else if (pos == 1884247150) {		pos = "OpenType-Zähler";	}	else if (pos == 1884247140) {		pos = "OpenType-Nenner";	}	else if (pos == 1851876449) {		pos = "nicht definiert";	}	scf.push("\tPosition\t" + pos);	var und = curProps.underline;	if (und == false) {		und = "nicht aktiviert";	}	else if (und == true) {		und = "aktiviert";	}	else if (und == 1851876449) {		und = "nicht definiert";	}	scf.push("\tUnterstrichen\t" + und);	var stk = curProps.strikeThru;	if (stk == false) {		stk = "nicht aktiviert";	}	else if (stk == true) {		stk = "aktiviert";	}	else if (stk == 1851876449) {		stk = "nicht definiert";	}	scf.push("\tDurchgestrichen\t" + stk);	var lig = curProps.ligatures;	if (lig == false) {		lig = "nicht aktiviert";	}	else if (lig == true) {		lig = "aktiviert";	}	else if (lig == 1851876449) {		lig = "nicht definiert";	}	scf.push("\tLigaturen\t" + lig);	var nbr = curProps.noBreak;	if (nbr == false) {nbr = "nicht aktiviert"}	else if (nbr == true) {nbr = "aktiviert"}	else if (nbr == 1851876449) {nbr = "nicht definiert"; }	scf.push("\tKein Umbruch\t" + nbr);	stdString = scf.join("\r");		// **********************************************	// das Panel "Erweiterte Zeichenformate"	// **********************************************	var sca = new Array ();	var hsc = curProps.horizontalScale;	if (hsc != 1851876449) {		sca.push("\tHorizontal skalieren\t" + hsc + "%");	}	else {		sca.push("\tHorizontal skalieren\tnicht definiert");	}	var vsc = curProps.verticalScale;	if (vsc != 1851876449) {		sca.push("\tVertikal skalieren\t" + vsc + "%");	}	else {		sca.push("\tVertikal skalieren\tnicht definiert");	}	var bls = curProps.baselineShift;	if (bls != 1851876449) {		sca.push("\tGrundlinienversatz\t" + bls + " Pt");	}	else {		sca.push("\tGrundlinienversatz\tnicht definiert");	}	var skw = curProps.skew;	if (skw != 1851876449) {		sca.push("\tVerzerren\t" + skw + "°");	}	else {		sca.push("\tVerzerren\tnicht definiert");	}	try {		var lga = curProps.appliedLanguage.name;		if (lga == null) {			lga = "nicht definiert";		}		sca.push("\tSprache\t" + lga);	}	catch (e) {		sca.push("\tSprache\tnicht definiert");	}	advString = sca.join("\r");		// **********************************************	// das Panel "Zeichenfarbe"	// **********************************************	var col = new Array ();	try {		var fco = curProps.fillColor.name;		if (fco == "None") { fco = "[Ohne]" }		else if (fco == "Black") { fco = "[Schwarz]" }		else if (fco == "Paper") { fco = "[Papier]" }		else if (fco == "Registration") { fco = "[Passermarken]" }		col.push("\tZeichenfarbe\t" + fco);	}	catch (e) {		col.push("\tZeichenfarbe\tnicht definiert");	}	var fti = curProps.fillTint;	if (fti != 1851876449) {		if (fti == -1) {			fti = 100;		}		col.push("\tFarbton\t" + fti + "%");	}	else {		col.push("\tFarbton\tnicht definiert");	}	var opf = curProps.overprintFill;	if (opf == true) {		opf = "ja";	}	else if (opf == false) {		opf = "nein";	}	else if (opf == 1851876449) {		opf = "nicht definiert";	}	col.push("\tFläche überdrucken\t" + opf);	try {		var sco = curProps.strokeColor.name;		if (sco == "None") { sco = "[Ohne]" }		else if (sco == "Black") { sco = "[Schwarz]" }		else if (sco == "Paper") { sco = "[Papier]" }		else if (sco == "Registration") { sco = "[Passermarken]" }		col.push("\tKontur: Farbe\t" + sco);	}	catch (e) {		col.push("\tKontur: Farbe\tnicht definiert");	}	var sti = curProps.strokeTint;	if (sti != 1851876449) {		if (sti == -1) {			sti = 100;		}		col.push("\tKontur: Farbton\t" + sti + "%");	}	else {		col.push("\tKontur: Farbton\tnicht definiert");	}	var swt = curProps.strokeWeight;	if (swt != 1851876449) {		col.push("\tKontur: Stärke\t" + swt + " Pt");	}	else {		col.push("\tKontur: Stärke\tnicht definiert");	}	var ops = curProps.overprintFill;	if (ops == true) {		ops = "ja";	}	else if (ops == false) {		ops = "nein";	}	else if (ops == 1851876449) {		ops = "nicht definiert";	}	col.push("\tKontur überdrucken\t" + ops);	var mil = curProps.miterLimit;	if (mil != 1851876449) {		col.push("\tKontur\tGehrungsgrenze: " + mil + " x");	}	else {		col.push("\tKontur\tGehrungsgrenze: nicht def.");	}	var sta = curProps.strokeAlignment;	if (sta = 1936998735) {		col.push("\tKonturausrichtung\taußen ausrichten");	}	else if (sta = 1936998723) {		col.push("\tKonturausrichtung\tmittig ausrichten");	}	var ejo = curProps.endJoin;	if (ejo = 1835691886) {		col.push("\tKonturecken\tGehrungsecken");	}	else if (ejo = 1919577966) {		col.push("\tKonturecken\tAbgerundete Ecken");	}	else if (ejo = 1651142510) {		col.push("\tKonturecken\tAbgeflachte Ecken");	}	var colString = col.join("\r");		// **********************************************	// das Panel "OpenType-Funktionen"	// **********************************************	var otf = new Array ();	var vCtr = 0;	var oti = curProps.otfTitling;	if (oti == true) {		otf.push("\tGroßbuchstabenvar.\taktiviert");		vCtr++;	}	var ofs = curProps.otfSwash;	if (ofs == true) {		otf.push("\tVerschnörkelte Var.\taktiviert");		vCtr++;	}	var oca = curProps.otfContextualAlternate;	if (oca == true) {		otf.push("\tKontextbedingte Var.\taktiviert");		vCtr++;	}	var ord = curProps.otfOrdinal;	if (ord == true) {		otf.push("\tOrdinalzeichen\taktiviert");		vCtr++;	}	var fra = curProps.otfFraction;	if (fra == true) {		otf.push("\tBrüche\taktiviert");		vCtr++;	}	var lig = curProps.otfDiscretionaryLigature;	if (lig == true) {		otf.push("\tBedingte Ligaturen\taktiviert");		vCtr++;	}	var zer = curProps.otfSlashedZero;	if (zer == true) {		otf.push("\tNull mit Schrägstrich\taktiviert");		vCtr++;	}	if (vCtr == 0) {		otf.push("\tCheckboxen\tkeine aktiviert");	}	var ofs = curProps.otfFigureStyle;	if (ofs == 1147563124) {		otf.push("\tZahlenformat\tStandardzahlenformat");	}	else if (ofs == 1330932848) {		otf.push("\tZahlenformat\tVersalziffern für Tabellen");	}	else if (ofs == 1330933619) {		otf.push("\tZahlenformat\tProportionale Mediävalziffern");	}	else if (ofs == 1330931316) {		otf.push("\tZahlenformat\tProportionale Versalziffern");	}	else if (ofs == 1330933620) {		otf.push("\tZahlenformat\tMediävalziffern für Tabellen");	}	var pof = curProps.positionalForm;	if (pof == 1852796517) {		otf.push("\tPositionalform\tAllgemeine Form");	}	else if (pof == 1634756205) {		otf.push("\tPositionalform\tAutomatische Form");	}	else if (pof == 1768843636) {		otf.push("\tPositionalform\tInitialform");	}	else if (pof == 1835361385) {		otf.push("\tPositionalform\tMedialform");	}	else if (pof == 1718185569) {		otf.push("\tPositionalform\tFinalform");	}	else if (pof == 1769172844) {		otf.push("\tPositionalform\tIsolierte Form");	}	var oss = curProps.otfStylisticSets;	var moreThanOne = false;	if (oss == 1851876449 || oss == 0) {		otf.push("\tFormatsätze\tKeine");	}	else {		if (oss == 2) { oss = "1"; }		else if (oss == 4) { oss = "2"; }		else if (oss == 8) { oss = "3"; }		else if (oss == 16) { oss = "4"; }		else if (oss == 32) { oss = "5"; }		else if (oss == 64) { oss = "6"; }		else if (oss == 128) { oss = "7"; }		else if (oss == 256) { oss = "8"; }		else if (oss == 512) { oss = "9"; }		else if (oss == 1024) { oss = "10"; }		else if (oss == 2048) { oss = "11"; }		else if (oss == 4096) { oss = "12"; }		else if (oss == 8192) { oss = "13"; }		else if (oss == 16384) { oss = "14"; }		else if (oss == 32768) { oss = "15"; }		else if (oss == 65536) { oss = "16"; }		else if (oss == 131072) { oss = "17"; }		else if (oss == 262144) { oss = "18"; }		else if (oss == 524288) { oss = "19"; }		else if (oss == 1048576) { oss = "20"; }		else {			moreThanOne = true;			if (oss == 2097150) {				otf.push("\tFormatsätze\tSätze 1 bis 20");			}			else {				var valList = new Array (1048576, 524288, 262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2);				var indList = new Array (20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);				var setList = new Array ();				for (var i=0; i<20; i++) {					curVal = oss - valList[i];					if (curVal > 0) {						oss = curVal;						setList.push(indList[i]);					}					else if (oss == valList[i]) {						setList.push(indList[i]);						break;					}				}				setList.reverse();				setString = setList.join(", ");				otf.push("\tFormatsätze\tSätze " + setString);			}		}		if (!moreThanOne) {			otf.push("\tFormatsätze\tSatz " + oss);		}	}	var otfString = otf.join("\r");		// **********************************************	// das Panel "Unterstreichungsoptionen"	// **********************************************	var uac = curProps.underline;	if (uac == false) {		undString = "\tUnterstreichung\tnicht aktiviert";	}	else if (uac == 1851876449) {		undString = "\tUnterstreichung\tnicht definiert";	}	else {		var und = new Array ();		var uCtr = 0;		var unw = curProps.underlineWeight;		if (unw == -9999) {			und.push("\tStärke\tAutom.");		}		else if (unw == 1851876449) {			und.push("\tStärke\tnicht definiert");			uCtr++;		}		else {			und.push("\tStärke\t" + unw + " Pt");		}		var uno = curProps.underlineOffset;		if (uno == -9999) {			und.push("\tOffset\tAutom.");		}		else if (uno == 1851876449) {			und.push("\tOffset\tnicht definiert");			uCtr++;		}		else {			und.push("\tOffset\t" + uno + " Pt");		}		try {			var unt = curProps.underlineType.name;			und.push("\tArt\t" + unt);		}		catch (e) {			und.push("\tArt\tnicht definiert");			uCtr++;		}		var unc = curProps.underlineColor;		if (unc == "Text Color") {			unc = "(Textfarbe)";		}		else {			try {				unc = unc.name;				if (unc == "None") { unc = "[Ohne]"; }				else if (unc == "Black") { unc = "[Schwarz]"; }				else if (unc == "Paper") { unc = "[Papier]"; }				else if (unc == "Registration") { unc = "[Passermarken]"; }				und.push("\tFarbe\t" + unc);			}			catch (e) {				und.push("\tFarbe\tnicht definiert");				uCtr++;			}		}		var uni = curProps.underlineTint;		if (uni != 1851876449) {			if (uni == -1) { uni = 100; }			und.push("\tFarbton\t" + uni + "%");		}		else {			und.push("\tFarbton\tnicht definiert");			uCtr++;		}		var unop = curProps.underlineOverprint;		if (unop == false) { unop = "nein"; }		else if (unop == true) { unop = "ja"; }		else if (unop == 1851876449) { 			unop = "nicht definiert";			uCtr++;		}		und.push("\tKontur überdrucken\t" + unop);		var ugCtr = 0;		if (unt != "Durchgezogen") {			var ungc = curProps.underlineGapColor;			if (ungc == "Text Color") {				und.push("\tFarbe für Lücke\t(Textfarbe)");			}			else {				try {					ungc = ungc.name;					if (ungc == "None") { ungc = "[Ohne]"; }					else if (ungc == "Black") { ungc = "[Schwarz]"; }					else if (ungc == "Paper") { ungc = "[Papier]"; }					else if (ungc == "Registration") { ungc = "[Passermarken]"; }					und.push("\tFarbe für Lücke\t" + ungc);				}				catch (e) {					und.push("\tFarbe für Lücke\tnicht definiert");					ugCtr++;				}			}			var ungi = curProps.underlineGapTint;			if (ungi != 1851876449) {				if (ungi == -1) { ungi = 100; }				und.push("\tFarbton für Lücke\t" + ungi + "%");			}			else {				und.push("\tFarbton für Lücke\tnicht definiert");				ugCtr++;			}			var ungo = curProps.underlineGapOverprint;			if (ungo == false) { ungo = "nein"; }			else if (ungo == true) { ungo = "ja"; }			else if (ungo == 1851876449) {				ungo = "nicht definiert";				ugCtr++;			}			und.push("\tLücke überdrucken\t" + ungo);		}		else {			ugCtr = 3;		}		if (uCtr == 6 && ugCtr == 3) {			undString = "\taktiviert\taber nichts ist definiert";		}		else {			undString = und.join("\r");		}	}		// **********************************************	// das Panel "Durchstreichungsoptionen"	// **********************************************	var sac = curProps.strikeThru;	if (sac == false) {		var strString = "\tDurchstreichung\tnicht aktiviert";	}	else if (sac == 1851876449) {		strString = "\tDurchstreichung\tnicht definiert";	}	else {		var str = new Array ();		var sCtr = 0;		var stw = curProps.strikeThroughWeight;		if (stw == -9999) {			str.push("\tStärke\tAutom.");		}		else if (stw == 1851876449) {			str.push("\tStärke\tnicht definiert");			sCtr++;		}		else {			str.push("\tStärke\t" + stw + " Pt");		}		var sto = curProps.strikeThroughOffset;		if (sto == -9999) {			str.push("\tOffset\tAutom.");		}		else if (sto == 1851876449) {			str.push("\tOffset\tnicht definiert");			sCtr++;		}		else {			str.push("\tOffset\t" + sto + " Pt");		}		try {			var stt = curProps.strikeThroughType.name;			str.push("\tArt\t" + stt);		}		catch (e) {			str.push("\tArt\tnicht definiert");			sCtr++;		}		var stc = curProps.strikeThroughColor;		if (stc == "Text Color") {			stc = "(Textfarbe)";		}		else {			try {				stc = stc.name;				if (stc == "None") { stc = "[Ohne]"; }				else if (stc == "Black") { stc = "[Schwarz]"; }				else if (stc == "Paper") { stc = "[Papier]"; }				else if (stc == "Registration") { stc = "[Passermarken]"; }				str.push("\tFarbe\t" + stc);			}			catch (e) {				str.push("\tFarbe\tnicht definiert");				sCtr++;			}		}		var sti = curProps.strikeThroughTint;		if (sti != 1851876449) {			if (sti == -1) { sti = 100; }			str.push("\tFarbton\t" + sti + "%");		}		else {			str.push("\tFarbton\tnicht definiert");			sCtr++;		}		var skop = curProps.strikeThroughOverprint;		if (skop == false) { skop = "nein"; }		else if (skop == true) { skop = "ja"; }		else if (skop == 1851876449) { 			skop = "nicht definiert";			sCtr++;		}		str.push("\tKontur überdrucken\t" + skop);		var sgCtr =0;		if (stt != "Durchgezogen") {			var stgc = curProps.strikeThroughGapColor;			if (stgc == "Text Color") {				str.push("\tFarbe für Lücke\t(Textfarbe)");			}			else {				try {					stgc = stgc.name;					if (stgc == "None") { stgc = "[Ohne]"; }					else if (stgc == "Black") { stgc = "[Schwarz]"; }					else if (stgc == "Paper") { stgc = "[Papier]"; }					else if (stgc == "Registration") { stgc = "[Passermarken]"; }					str.push("\tFarbe für Lücke\t" + stgc);				}				catch (e) {					str.push("\tFarbe für Lücke\tnicht definiert");					sgCtr++;				}			}			var stgi = curProps.strikeThroughGapTint;			if (stgi != 1851876449) {				if (stgi == -1) { stgi = 100; }				str.push("\tFarbton für Lücke\t" + stgi + "%");			}			else {				str.push("\tFarbton für Lücke\tnicht definiert");				sgCtr++;			}			var stgo = curProps.strikeThroughGapOverprint;			if (stgo == false) { stgo = "nein"; }			else if (stgo == true) { stgo = "ja"; }			else if (stgo == undefined) { stgo = "nicht definiert" }			else if (stgo == 1851876449) {				stgo = "nicht definiert";				sgCtr++;			}			str.push("\tLücke überdrucken\t" + stgo);		}		else {			sgCtr = 3;		}		if (sCtr == 6 && sgCtr == 3) {			strString = "\taktiviert\taber nichts ist definiert";		}		else {			strString = str.join("\r");		}	}		// **********************************************	// einen Textrahmen erzeugen	var newFrame = newCharDoc.pages.item(-1).textFrames.add();	if (pCtr%2==0 || oneStyle) {		newFrame.properties = {geometricBounds:[12, 15, 285, 105.5]};	}	else {		newFrame.properties = {geometricBounds:[12, 109.5, 285, 200]};	}		// eine neue Liste vorbereiten	var propsList = new Array (15);		// die Elemente zuweisen	propsList[0] = "Dokument  " + docName;	propsList[1] = "\r\tFormatname\t" + snm;	propsList[2] = genString; // Zeile 1955	propsList[3] = "\rGrundlegende Zeichenformate"; // Zeile 1984	propsList[4] = stdString;	propsList[5] = "\rErweiterte Zeichenformate"; // Zeile 2119	propsList[6] = advString;	propsList[7] = "\rZeichenfarbe"; // Zeile 2163	propsList[8] = colString;	propsList[9] = "\rOpenType-Funktionen"; // Zeile 2264	propsList[10] = otfString;	propsList[11] = "\rUnterstreichungsoptionen"; // Zeile 2399	propsList[12] = undString;	propsList[13] = "\rDurchstreichungsoptionen"; // Zeile 2526	propsList[14] = strString;		// die Liste in eine Textkette verwandeln ...	var propsString = propsList.join("\r");	// ... in den Rahmen einsetzen ...	var curStory = newFrame.parentStory;	curStory.contents = propsString;	// ... und formatieren	try {		curStory.appliedParagraphStyle = newCharDoc.paragraphStyles.item("02_Definitionen");	}	catch (e) {	}	// die Untertitel formatieren	try {		curStory.paragraphs.item(0).appliedParagraphStyle = newCharDoc.paragraphStyles.item("01_Untertitel");	}	catch (e) {	}	var nParas = curStory.paragraphs.length;	for (var p=0; p<nParas; p++) {		if (curStory.paragraphs[p].characters.length == 1) {			try {				curStory.paragraphs.item(p+1).appliedParagraphStyle = newCharDoc.paragraphStyles.item("01_Untertitel");			}			catch (e) {			}		}	}	// einigen Zeichen wieder den Stil "Regular" zuweisen	try {		curStory.paragraphs.item(0).characters.itemByRange(0, 9).fontStyle = "Regular";	}	catch (e) {	}	try {		curStory.paragraphs.item(2).characters.itemByRange(0,11).fontStyle = "Regular";	}	catch (e) {	}	// die Anzahl Zeilen zweier Absätze prüfen und, falls notwendig, einen Shift-Return einfügen	var testPara1 = curStory.paragraphs.item(2); // Formatname	if (testPara1.lines.length == 2) {		try {			testPara1.characters.item(11).contents = 1397124194;			testPara1.insertionPoints.item(12).contents = 1397909876;		}		catch (e) {		}	}	var testPara2 = curStory.paragraphs.item(3+grp); // Basiert auf	if (testPara2.lines.length == 2) {		try {			testPara2.characters.item(12).contents = 1397124194;			testPara2.insertionPoints.item(13).contents = 1397909876;		}		catch (e) {		}	}	var testPara4 = curStory.paragraphs.item(24+grp); // Sprache	if (testPara4.lines.length == 2) {		try {			testPara4.characters.item(8).contents = 1397124194;			testPara4.insertionPoints.item(9).contents = 1397909876;		}		catch (e) {		}	}		// die Leerzeilen entfernen	app.findTextPreferences = app.changeTextPreferences = null;	app.findTextPreferences.findWhat = "\r\r";	app.changeTextPreferences.changeTo = "\r";	curStory.changeText();	app.findTextPreferences = app.changeTextPreferences = null;}// ein neues Dokument erzeugenfunction makeDoc() {	with (app.marginPreferences){		// die Vorgabewerte der Ränder speichern		var oldY1 = top;		var oldX1 = left;		var oldY2 = bottom;		var oldX2 = right;		// die Vorgabewerte der Ränder ändern		top = 0;		left = 0;		bottom = 0;		right = 0;	}	// das Dokument erzeugen	var newDoc = app.documents.add();	newDoc.documentPreferences.properties = {pageWidth:210, pageHeight:297, facingPages:false};	// die Tab-Stops definieren	var mainTabs = new Array (2);	mainTabs[0] = {alignment:TabStopAlignment.rightAlign, position:36};	mainTabs[1] = {alignment:TabStopAlignment.leftAlign, position:40};	// zwei Absatzformate erzeugen	try {		var pStyle1 = newDoc.paragraphStyles.add();		pStyle1.name = "01_Untertitel";		pStyle1.properties = {pointSize:12, leading: 14, fillColor:"Black", fillTint:-1, 			justification:Justification.leftAlign, alignToBaseline:false, tabList:mainTabs, 			fontStyle:"Bold", spaceBefore:3, ruleAbove:true, ruleAboveLineWeight:.5, ruleAboveOffset:5};	}	catch (e) {	}	try {		var pStyle2 = newDoc.paragraphStyles.add();		pStyle2.name = "02_Definitionen";		pStyle2.properties = {pointSize:12, leading: 14, fillColor:"Black", fillTint:-1, 			justification:Justification.leftAlign, alignToBaseline:false, tabList:mainTabs};	}	catch (e) {	}	return [newDoc, oldY1, oldX1, oldY2, oldX2];}// die geänderten Programmvorgaben zurücksetzenfunction restoreApp(oldY1, oldX1, oldY2, oldX2) {	with (app.marginPreferences){		top = oldY1;		left = oldX1;		bottom = oldY2;		right = oldX2;	}}