//F3_WerteRunden_403d.js / CS4//© 29.12.08 / Hans Haesler, Châtelard 52, CH-1018 Lausanne//Dieses Script dient zum Runden von Werten mit vielen Nachkommastellen//auf die Zahl, welche in den Dialogen der Absatz- und Zeichenformate erscheintif (app.documents.length == 0) {	alert ("Es ist kein Dokument offen.", "Achtung");	exit();}// prüfen, ob Absatzformat-Gruppen bestehenparaGroups = app.documents[0].paragraphStyleGroups;var nPSG = paraGroups.length;// prüfen, ob Zeichenformat-Gruppen bestehencharGroups = app.documents[0].characterStyleGroups;var nCSG = charGroups.length;//--- die Liste der Absatzformatnamen aufstellen ---//if (nPSG == 0) {	var dlogPStyles = app.documents[0].paragraphStyles.everyItem().name;	// das erste Element durch ein Sternchen ersetzen	dlogPStyles[0] = "*";	// zu Beginn ein leeres Element einfügen	dlogPStyles = [""].concat(dlogPStyles);	nDlogPStyles = dlogPStyles.length;}else {	pGroupNames = paraGroups.everyItem().name;	pGroupNames = ["[Root]"].concat(pGroupNames);	var dlogPStyles = app.documents[0].paragraphStyles.everyItem().name;	// bei jedem Element drei Leerräume einfügen	for (var i=0; i<dlogPStyles.length; i++) {		curName = "   " + dlogPStyles[i];		dlogPStyles[i] = curName;	}	// das erste Element durch "[Root]" ersetzen	dlogPStyles[0] = "[Root]";	// zu Beginn ein Sternchen einfügen	dlogPStyles = ["*"].concat(dlogPStyles);	// zu Beginn ein leeres Element einfügen	dlogPStyles = [""].concat(dlogPStyles);	// eine Schleife durch die Gruppen	for (var i=0; i<nPSG; i++) {		var curGroup = paraGroups[i];		var curParaStyles = curGroup.paragraphStyles.everyItem().name;		// bei jedem Element drei Leerräume einfügen		for (var k=0; k<curParaStyles.length; k++) {			curName = "   " + curParaStyles[k];			curParaStyles[k] = curName;		}		// ein Element mit dem Namen der Gruppe voranstellen		curParaStyles = [curGroup.name].concat(curParaStyles);		dlogPStyles = dlogPStyles.concat(curParaStyles);	}	nDlogPStyles = dlogPStyles.length;	// die Positionen der Gruppennamen feststellen	var pGroupIDs = new Array ();	pGroupIDs.push(0);	for (var i=2; i<nDlogPStyles; i++) {		if (dlogPStyles[i][0] != " ") {			pGroupIDs.push(i);		}	}	// die Reihenfolge der Liste umkehren	pGroupIDs.reverse();}//--- die Liste der Zeichenformatnamen aufstellen ---//if (nCSG == 0) {	var dlogCStyles = app.documents[0].characterStyles.everyItem().name;	// das erste Element durch ein Sternchen ersetzen	dlogCStyles[0] = "*";	// zu Beginn ein leeres Element einfügen	dlogCStyles = [""].concat(dlogCStyles);	nDlogCStyles = dlogCStyles.length;}else {	cGroupNames = charGroups.everyItem().name;	cGroupNames = ["[Root]"].concat(cGroupNames);	var dlogCStyles = app.documents[0].characterStyles.everyItem().name;	// bei jedem Element drei Leerräume einfügen	for (var i=0; i<dlogCStyles.length; i++) {		curName = "   " + dlogCStyles[i];		dlogCStyles[i] = curName;	}	// das erste Element durch "[Root]" ersetzen	dlogCStyles[0] = "[Root]";	// zu Beginn ein Sternchen einfügen	dlogCStyles = ["*"].concat(dlogCStyles);	// zu Beginn ein leeres Element einfügen	dlogCStyles = [""].concat(dlogCStyles);	// eine Schleife durch die Gruppen	for (var i=0; i<nCSG; i++) {		var curGroup = charGroups[i];		var curCharStyles = curGroup.characterStyles.everyItem().name;		// bei jedem Element drei Leerräume einfügen		for (var k=0; k<curCharStyles.length; k++) {			curName = "   " + curCharStyles[k];			curCharStyles[k] = curName;		}		// ein Element mit dem Namen der Gruppe voranstellen		curCharStyles = [curGroup.name].concat(curCharStyles);		dlogCStyles = dlogCStyles.concat(curCharStyles);	}	nDlogCStyles = dlogCStyles.length;	// die Positionen der Gruppennamen feststellen	var cGroupIDs = new Array ();	cGroupIDs.push(0);	for (var i=2; i<nDlogCStyles; i++) {		if (dlogCStyles[i][0] != " ") {			cGroupIDs.push(i);		}	}	// die Reihenfolge der Liste umkehren	cGroupIDs.reverse();}// Dialoge, welche eventuell im Speicher geblieben sind, löschentry {	app.dialogs.everyItem().destroy();}catch (e) {}// vorbeugenderweise das Anzeigen von Dialogen aktivierenapp.scriptPreferences.userInteractionLevel = UserInteractionLevels.interactWithAll;// einen Dialog erzeugenvar aDialog = app.dialogs.add({name:"Das Format auswählen", canCancel:true});with (aDialog) {	with (dialogColumns.add()) {		with (dialogRows.add()) {			staticTexts.add({staticLabel:"Absatzformate:"});			staticTexts.add({staticLabel:" "});		}		with (borderPanels.add()) {			with (dialogColumns.add()) {				var paraName = dropdowns.add({stringList:dlogPStyles, selectedIndex:0, minWidth:180});			}		}		with (dialogRows.add()) {			staticTexts.add({staticLabel:"Zeichenformate:"});			staticTexts.add({staticLabel:" "});		}		with (borderPanels.add()) {			with (dialogColumns.add()) {				var charName = dropdowns.add({stringList:dlogCStyles, selectedIndex:0, minWidth:180});			}		}	}	with (dialogColumns.add()) {		staticTexts.add({staticLabel:"", minWidth:4});	}}// den Dialog zeigenif (aDialog.show() == true) {	// die Wahl des Anwenders übernehmen	var paraID = paraName.selectedIndex;	var charID = charName.selectedIndex;	// den Dialog aus dem Speicher entfernen	aDialog.destroy();}else {	aDialog.destroy();	exit();}// die Wahl des Anwenders prüfenif (paraID != 0) {	var curGroup;	var curPara ;	var grpName;	var nParaStyles;	if (paraID == 1) {		var paraString = "";		try {			// wenn das Sternchen gewählt worden ist, versuchen, 			// den Inhalt des Textrahmens "ParaStyles" zu speichern			paraString = app.documents[0].textFrames.item("ParaStyles").parentStory.contents;		}		catch (e) {		}		if (paraString != "") {			paraStyles = paraString.split("\r");			nParaStyles = paraStyles.length;			// wenn keine Formatgruppen vorhanden sind			if (nPSG == 0) {				for (var s=0; s<nParaStyles; s++) {					curPara = paraStyles[s];					roundParaVals(curPara, "");				}			}			// die Behandlung der Gruppen ist etwas komplizierter			else {				for (var s=0; s<nParaStyles; s++) {					curPara = paraStyles[s];					if (curPara[0] != " ") {						grpName = curPara;					}					else {						curPara = curPara.slice(3);						roundParaVals(curPara, grpName);					}				}			}		}		// wenn der Textrahmen "ParaStyles" nicht vorhanden ist ...		else {			// ... falls keine Formatgruppen vorhanden sind ...			if (nPSG == 0) {				for (var s=2; s<nDlogPStyles; s++) {					curPara = dlogPStyles[s];					roundParaVals(curPara, grpName);				}			}			// ... sonst die komplizierte Behandlung der Gruppen durchführen ...			else {				for (var s=2; s<nDlogPStyles; s++) {					curPara = dlogPStyles[s];					if (curPara[0] != " ") {						grpName = curPara;						if (grpName != "[Root]") {							curGroup = app.documents[0].paragraphStyleGroups.item(grpName);							paraStyles = curGroup.allParagraphStyles;							nParaStyles = paraStyles.length;							for (var j=0; j<nParaStyles; j++) {								curPara = paraStyles[j].name;								roundParaVals(curPara, grpName);							}						}						else {							paraStyles = app.documents[0].paragraphStyles;							nParaStyles = paraStyles.length;							for (var j=1; j<nParaStyles; j++) {								curPara = paraStyles[j].name;								roundParaVals(curPara, grpName);							}						}					}				}			}		}	}	// bei der Wahl eines anderen Artikels wird nur das betreffende Format behandelt ...	else {		curPara = dlogPStyles[paraID];		// wenn keine Gruppen vorhanden sind, ist es einfacher ...		if (nPSG == 0) {			roundParaVals(curPara, "");		}		// ... sonst müssen die Gruppen berücksichtigt werden		else {			// wenn ein Gruppenname ausgewählt ist, dann wird die ganze Gruppe ausgegeben			if (curPara[0] != " ") {				grpName = curPara;				if (grpName != "[Root]") {					curGroup = app.documents[0].paragraphStyleGroups.item(grpName);					paraStyles = curGroup.allParagraphStyles;					nParaStyles = paraStyles.length;					for (var s=0; s<nParaStyles; s++) {						curPara = paraStyles[s].name;						roundParaVals(curPara, grpName);					}				}				else {					paraStyles = app.documents[0].paragraphStyles;					nParaStyles = paraStyles.length;					for (var s=1; s<nParaStyles; s++) {						curPara = paraStyles[s].name;						roundParaVals(curPara, grpName);					}				}			}			// wenn ein Formatname ausgewählt ist, muss der Gruppenname festgestellt werden			else {				grpName = undefined;				// die drei Leerräume entfernen				curPara = curPara.slice(3);				// die Liste der Gruppennamen umkehren				pGroupNames.reverse();				// eine Schleife durch die Liste				for (var s=0; s<pGroupIDs.length; s++) {					// wenn die Position der Gruppe kleiner ist als jene des Formates					// den zugehörigen Namen übernehmen					if (pGroupIDs[s]<paraID) {						grpName = pGroupNames[s];						break;					}				}				if (grpName != undefined) {					roundParaVals(curPara, grpName);				}			}		}	}}// dasselbe mit einem gewählten Zeichenstilformatif (charID != 0) {	var charStyles;	var curChar;	var curGroup;	var grpName;	var nCharStyles;	if (charID == 1) {		var charString = "";		try {			var charString = app.documents[0].textFrames.item("CharStyles").parentStory.contents;		}		catch (e) {		}		if (charString != "") {			charStyles = charString.split("\r");			nCharStyles = charStyles.length;			if (nCSG == 0) {				for (var s=0; s<nCharStyles; s++) {					curChar = charStyles[s];					roundCharVals(curChar, "");				}			}			else {				for (var s=0; s<nCharStyles; s++) {					curChar = charStyles[s];					if (curChar[0] != " ") {						grpName = curChar;					}					else {						curChar = curChar.slice(3);						roundCharVals(curChar, grpName);					}				}			}		}		else {			if (nCSG == 0) {				for (var s=2; s<nDlogCStyles; s++) {					curChar = dlogCStyles[s];					roundCharVals(curChar, "");				}			}			else {				for (var s=2; s<nDlogCStyles; s++) {					curChar = dlogCStyles[s];					if (curChar[0] != " ") {						grpName = curChar;						if (grpName != "[Root]") {							curGroup = app.documents[0].characterStyleGroups.item(grpName);							charStyles = curGroup.allCharacterStyles;							nCharStyles = charStyles.length;							for (var j=0; j<nCharStyles; j++) {								curChar = charStyles[j].name;								roundCharVals(curChar, grpName);							}						}						else {							charStyles = app.documents[0].characterStyles;							nCharStyles = charStyles.length;							for (var j=1; j<nCharStyles; j++) {								curChar = charStyles[j].name;								roundCharVals(curChar, grpName);							}						}					}				}			}		}	}	else {		curChar = dlogCStyles[charID];		if (nCSG == 0) {			roundCharVals(curChar, "");		}		else {			if (curChar[0] != " ") {				grpName = curChar;				if (grpName != "[Root]") {					curGroup = app.documents[0].characterStyleGroups.item(grpName);					charStyles = curGroup.allCharacterStyles;					nCharStyles = charStyles.length;					for (var s=0; s<nCharStyles; s++) {						curChar = charStyles[s].name;						roundCharVals(curChar, grpName);					}				}				else {					charStyles = app.documents[0].characterStyles;					nCharStyles = charStyles.length;					for (var s=1; s<nCharStyles; s++) {						curChar = charStyles[s].name;						roundCharVals(curChar, grpName);					}				}			}			else {				grpName = undefined;				curChar = curChar.slice(3);				cGroupNames.reverse();				for (var s=0; s<cGroupIDs.length; s++) {					if (cGroupIDs[s]<charID) {						grpName = cGroupNames[s];						break;					}				}				if (grpName != undefined) {					roundCharVals(curChar, grpName);				}			}		}	}}// den Anwender informierenalert ("Fertig.", " ");//**********************************************************// die Absatzformat-Werte auf drei Nachkommastellen kürzen//**********************************************************function roundParaVals(curPara, grpName) {	try {		// die Attribute des aktuellen Absatzformates speichern		if (nPSG == 0) {			curPara = app.documents[0].paragraphStyles.item(curPara);			curProps = curPara.properties;		}		else {			if (grpName != "[Root]") {				var curGroup = app.documents[0].paragraphStyleGroups.item(grpName);				var curPara = curGroup.paragraphStyles.item(curPara);				curProps = curPara.properties;			}			else {				curPara = app.documents[0].paragraphStyles.item(curPara);				curProps = curPara.properties;			}		}	}	catch (e) {		return;	}	try {		// Schriftgröße		var siz = curProps.pointSize;		siz = Math.floor((siz*1000) + 0.5) / 1000;		// Zeilenabstand		var led = curProps.leading;		led = Math.floor((led*1000) + 0.5) / 1000;		// horizontale Skalierung		var hsc = curProps.horizontalScale;		hsc = Math.floor((hsc*1000) + 0.5) / 1000;		// Grundlinienversatz		var bls = curProps.baselineShift;		bls = Math.floor((bls*1000) + 0.5) / 1000;		// Einzug links		var lin = curProps.leftIndent;		lin = Math.floor((lin*1000) + 0.5) / 1000;		// Einzug erste Zeile		var fln = curProps.firstLineIndent;		fln = Math.floor((fln*1000) + 0.5) / 1000;		// Einzug rechts		var rin = curProps.rightIndent;		rin = Math.floor((rin*1000) + 0.5) / 1000;		// Abstand vor		var spb = curProps.spaceBefore;		spb = Math.floor((spb*1000) + 0.5) / 1000;		// Abstand nach		var spa = curProps.spaceAfter;		spa = Math.floor((spa*1000) + 0.5) / 1000;		// Wortabstand		var mws = curProps.minimumWordSpacing;		mws = Math.floor(mws + 0.5);		// Autom. Zeilenabstand		var ald = curProps.autoLeading;		ald = Math.floor(ald + 0.5);		// die gerundeten Werte zuweisen		curPara.properties = {pointSize:siz, leading:led, horizontalScale:hsc, baselineShift:bls, 			leftIndent:lin, firstLineIndent:fln, rightIndent:rin, spaceBefore:spb, spaceAfter:spa, 			minimumWordSpacing:mws, autoLeading:ald};				// Tabulatorpositionen		var tbl = curProps.tabList;		var nTabs = tbl.length;		if (nTabs != 0) {			for (var i=0; i<nTabs; i++) {				var curPos = tbl[i].position;				curPos = Math.floor((curPos*1000) + 0.5) / 1000;				tbl[i].position = curPos;			}			// die gerundeten Werte zuweisen			curPara.properties = {tabList:tbl};		}				// Absatzlinie darüber		var rab = curProps.ruleAbove;		if (rab) {			var raw = curProps.ruleAboveLineWeight;			raw = Math.floor((raw*1000) + 0.5) / 1000;			var rao = curProps.ruleAboveOffset;			rao = Math.floor((rao*1000) + 0.5) / 1000;			var rali = curProps.ruleAboveLeftIndent;			rali = Math.floor((rali*1000) + 0.5) / 1000;			var rari = curProps.ruleAboveRightIndent;			rari = Math.floor((rari*1000) + 0.5) / 1000;			// die gerundeten Werte zuweisen			curPara.properties = {ruleAboveLineWeight:raw, ruleAboveOffset:rao, ruleAboveLeftIndent:rali, ruleAboveRightIndent:rari};		}		// Absatzlinie darunter		var rbe = curProps.ruleBelow;		if (rbe) {			var rbw = curProps.ruleBelowLineWeight;			rbw = Math.floor((rbw*1000) + 0.5) / 1000;			var rbo = curProps.ruleBelowOffset;			rbo = Math.floor((rbo*1000) + 0.5) / 1000;			var rbli = curProps.ruleBelowLeftIndent;			rbli = Math.floor((rbli*1000) + 0.5) / 1000;			var rbri = curProps.ruleBelowRightIndent;			rbri = Math.floor((rbri*1000) + 0.5) / 1000;			// die gerundeten Werte zuweisen			curPara.properties = {ruleBelowLineWeight:rbw, ruleBelowOffset:rbo, ruleBelowLeftIndent:rbli, ruleBelowRightIndent:rbri};		}	}	catch (e) {	}}//***********************************************************// die Zeichenformat-Werte auf drei Nachkommastellen kürzen//***********************************************************function roundCharVals(curChar, grpName) {	// die Attribute des aktuellen Zeichenformates speichern	try {		if (nCSG == 0) {			curChar = app.documents[0].characterStyles.item(curChar);			curProps = curChar.properties;		}		else {			if (grpName != "[Root]") {				var curGroup = app.documents[0].characterStyleGroups.item(grpName);				var curChar = curGroup.characterStyles.item(curChar);				curProps = curChar.properties;			}			else {				curChar = app.documents[0].characterStyles.item(curChar);				curProps = curChar.properties;			}		}	}	catch (e) {		return;	}	try {		// Schriftgröße		var siz = curProps.pointSize;		siz = Math.floor((siz*1000) + 0.5) / 1000;		// den gerundeten Wert zuweisen		curChar.pointSize = siz;	}	catch (e) {	}	try {		// Zeilenabstand		var led = curProps.leading;		led = Math.floor((led*1000) + 0.5) / 1000;		// den gerundeten Wert zuweisen		curChar.leading = led;	}	catch (e) {	}	try {		// horizontale Skalierung		var hsc = curProps.horizontalScale;		hsc = Math.floor((hsc*1000) + 0.5) / 1000;		// den gerundeten Wert zuweisen		curChar.horizontalScale = hsc;	}	catch (e) {	}	try {		// Grundlinienversatz		var bls = curProps.baselineShift;		bls = Math.floor((bls*1000) + 0.5) / 1000;		// den gerundeten Wert zuweisen		curChar.baselineShift = bls;	}	catch (e) {	}}